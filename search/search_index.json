{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QWGraph Documentation","text":"<p>This is the documentation for the python package <code>qwgraph</code>.  This package's aim is to provide an efficient implementation of quantum walks on graphs. </p> <p>The quantum walk model implemented in this package follows the paper https://arxiv.org/abs/2310.10451 . This model is specifically designed for searching.</p> <p>Most of the critical functions of this package are implemented and compiled in rust, providing an efficient simulation.</p>"},{"location":"#installation","title":"Installation","text":"<p>TODO</p>"},{"location":"coins/","title":"Coins","text":""},{"location":"coins/#qwgraph.coins.Cx","title":"<code>Cx</code>","text":"\\[ C_x = \\frac{1}{\\sqrt{2}}\\left(\\begin{matrix} 1 &amp; i \\\\ i &amp; 1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.Cy","title":"<code>Cy</code>","text":"\\[ C_y = \\frac{1}{\\sqrt{2}}\\left(\\begin{matrix} 1 &amp; -i \\\\ -i &amp; 1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.H","title":"<code>H</code>","text":"\\[ H = \\frac{1}{\\sqrt{2}}\\left(\\begin{matrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.I","title":"<code>I</code>","text":"\\[ I = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.S","title":"<code>S</code>","text":"\\[ S = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; i \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.T","title":"<code>T</code>","text":"\\[ T = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\frac{\\pi}{4}} \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.X","title":"<code>X</code>","text":"\\[ X = \\left(\\begin{matrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.Z","title":"<code>Z</code>","text":"\\[ Z = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.generalized_coin","title":"<code>generalized_coin(theta, phi, lbd)</code>","text":"<p>General coin</p> \\[ U(\\theta,\\phi,\\lambda) = \\left(\\begin{matrix} \\cos \\theta &amp; -e^{i\\lambda} \\sin \\theta \\\\ e^{i\\lambda} \\sin \\theta &amp; e^{i(\\lambda+\\phi)} \\cos \\theta \\\\ \\end{matrix}\\right) \\] <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>The angle \\(\\theta\\).</p> required <code>phi</code> <code>float</code> <p>The angle \\(\\phi\\).</p> required <code>lbd</code> <code>float</code> <p>The angle \\(\\lambda\\).</p> required <p>Returns:</p> Type Description <code>(complex numpy array)</code> <p>\\(U(\\theta,\\phi,\\lambda)\\)</p> Source code in <code>qwgraph/coins.py</code> <pre><code>def generalized_coin(theta, phi, lbd):\n\t\"\"\" General coin\n\n\t$$\n\tU(\\\\theta,\\\\phi,\\\\lambda) = \\\\left(\\\\begin{matrix}\n\t\\\\cos \\\\theta &amp; -e^{i\\\\lambda} \\\\sin \\\\theta \\\\\\\\\n\te^{i\\\\lambda} \\\\sin \\\\theta &amp; e^{i(\\\\lambda+\\\\phi)} \\\\cos \\\\theta \\\\\\\\\n\t\\\\end{matrix}\\\\right)\n\t$$\n\n\tArgs:\n\t\ttheta (float): The angle $\\\\theta$.\n\t\tphi (float): The angle $\\\\phi$.\n\t\tlbd (float): The angle $\\\\lambda$.\n\n\tReturns:\n\t\t(complex numpy array): $U(\\\\theta,\\\\phi,\\\\lambda)$\n\t\"\"\"\n\treturn np.array([[np.cos(theta) , -np.exp(1j*lbd)*np.sin(theta)],\n\t\t[np.exp(1j*lbd)*np.sin(theta) , np.exp(1j*(lbd+phi))*np.cos(theta)]],dtype=complex)\n</code></pre>"},{"location":"coins/#qwgraph.coins.phase_shift","title":"<code>phase_shift(phi)</code>","text":"<p>Phase shift coin</p> \\[ P(\\phi) = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; e^{i(\\phi)}\\\\ \\end{matrix}\\right) \\] <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>The angle \\(\\phi\\).</p> required <p>Returns:</p> Type Description <code>(complex numpy array)</code> <p>\\(P(\\phi)\\)</p> Source code in <code>qwgraph/coins.py</code> <pre><code>def phase_shift(phi):\n\t\"\"\" Phase shift coin\n\n\t$$\n\tP(\\\\phi) = \\\\left(\\\\begin{matrix}\n\t1 &amp; 0 \\\\\\\\\n\t0 &amp; e^{i(\\\\phi)}\\\\\\\\\n\t\\\\end{matrix}\\\\right)\n\t$$\n\n\tArgs:\n\t\tphi (float): The angle $\\\\phi$.\n\n\tReturns:\n\t\t(complex numpy array): $P(\\\\phi)$\n\t\"\"\"\n\treturn np.array([\n\t\t[1,0],\n\t\t[0,np.exp(1j*phi)]],dtype=complex)\n</code></pre>"},{"location":"qwsearch/","title":"Documentation for QWSearch","text":"<p>The class <code>qwgraph.QWSearch</code> contains everything to create and run quantum walks or search based quantum walks. In order to specify the underlying graph of the QW, the use of networkx is required.</p>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch","title":"<code> QWSearch        </code>","text":"<p>The Quantum Walk based search class. An instance of this class will be a Quantum Walk on a given graph. Methods are provided to modify and access the QW state and to run the QWSearch.</p> <p>Both the Quantum Walk and searching process are described in https://arxiv.org/abs/2310.10451</p> <p>Attributes:</p> Name Type Description <code>step</code> <code>int</code> <p>The current step (or epoch). Modifying this attribute will only change the step column of the <code>search</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>networkx.Graph</code> <p>The graph on which the QW will be defined.</p> required <code>search_nodes</code> <code>bool</code> <p>If True, the graph will be starified and the QW will be tuned to search nodes instead of edges. </p> <code>False</code> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>class QWSearch:\n    \"\"\" \n    The Quantum Walk based search class. An instance of this class will be a Quantum Walk on a given graph.\n    Methods are provided to modify and access the QW state and to run the QWSearch.\n\n    Both the Quantum Walk and searching process are described in https://arxiv.org/abs/2310.10451\n\n    Attributes:\n        step (int): The current step (or epoch). Modifying this attribute will only change the step column of the `search` method.\n\n    Args:\n        graph (networkx.Graph): The graph on which the QW will be defined.\n        search_nodes (bool, optional): If True, the graph will be starified and the QW will be tuned to search nodes instead of edges. \n\n\n    \"\"\"\n    def __init__(self, graph, search_nodes=False):\n        self.__search_nodes = search_nodes\n\n        self.__G = copy.deepcopy(graph)\n\n        if self.__search_nodes:\n            self.__virtual_edges = self.__starify()\n        else:\n            self.__virtual_edges = {}\n\n        self.__edges = list(self.__G.edges()) # List of edges\n        self.__nodes = list(self.__G.nodes()) # List of nodes\n        self.__index = {self.__edges[i]:i for i in range(len(self.__edges))} # Index for edges\n        self.__E = len(self.__edges) # Number of edges\n        self.__N = len(self.__nodes) # Number of nodes\n\n        if nx.bipartite.is_bipartite(self.__G):\n            color = nx.bipartite.color(self.__G) # Coloring\n        else:\n            color = {self.__nodes[i]:i for i in range(len(self.__nodes))} # Coloring\n\n        self.set_color(color)\n\n\n\n    def __initalize_rust_object(self):\n        self.__amplitude_labels = [\"\"]*2*self.__E\n        wiring = [] # For any amplitude self.state[i], says to which node it is connected. Important for the scattering.\n        tmp = {self.__nodes[i]:i  for i in range(self.__N)}\n        k = 0\n        for (i,j) in self.__edges:\n            edge_label = str(i) + \",\" + str(j)\n            if self.__color[i]&lt;self.__color[j]:\n                wiring.append(tmp[i])\n                wiring.append(tmp[j])\n                self.__amplitude_labels[k] = \"$\\psi_{\"+edge_label+\"}^-$\"\n                self.__amplitude_labels[k+1] = \"$\\psi_{\"+edge_label+\"}^+$\"\n            else:\n                wiring.append(tmp[j])\n                wiring.append(tmp[i])\n                self.__amplitude_labels[k] = \"$\\psi_{\"+edge_label+\"}^+$\"\n                self.__amplitude_labels[k+1] = \"$\\psi_{\"+edge_label+\"}^-$\"\n            k+=2\n\n\n        self.__qwf = qwfast.QWFast(wiring,self.__N,self.__E)\n\n        self.reset()\n\n\n    def __starify(self):\n        nodes = copy.deepcopy(self.__G.nodes())\n        s = {}\n        for i in nodes:\n            self.__G.add_edge(i,f\"new_node{i}\")\n            s[i] = (i,f\"new_node{i}\")\n        return s\n\n    def nodes(self):\n        \"\"\" Returns the list of nodes. Convenient when declaring which nodes are marked.\n\n        Returns:\n            (list of node): The list of nodes of the underlying graph.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.nodes()\n            [0, 1, 2, 3]\n\n        \"\"\"\n        return deepcopy(self.__nodes)\n\n    def edges(self):\n        \"\"\" Returns the list of edges. Convenient when declaring which edges are marked.\n\n        Returns:\n            (list of edge): The list of edges of the underlying graph.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.edges()\n            [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n\n        \"\"\"\n        return deepcopy(self.__edges)\n\n    def graph(self):\n        \"\"\" Returns the underlying graph.\n\n        Returns:\n            (networkx.Graph): The underlying graph.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.graph()\n            &lt;networkx.classes.graph.Graph at 0x7bd045d53c70&gt;\n\n        \"\"\"\n        return deepcopy(self.__G)\n\n    def virtual_edges(self):\n        \"\"\" Returns a dictionnary that associates its virtual edge to each node. This dictionnary is empty when the object has been built with `search_nodes==False` since there are no virtual edges in that case.\n\n        Returns:\n            (dict): A dictionnary {node: edge} that associates each node to its virtual edge.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.virtual_edges()\n            {}\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4),search_nodes=True)\n            &gt;&gt;&gt; qw.virtual_edges()\n            {0: (0, 'new_node0'),\n             1: (1, 'new_node1'),\n             2: (2, 'new_node2'),\n             3: (3, 'new_node3')}\n\n        \"\"\"\n        return deepcopy(self.__virtual_edges)\n\n    def color(self):\n        \"\"\" Returns the coloring of the underlying graph. This coloring is essential for the QW to be well defined.\n\n        The coloring is calculated when the object is built. Two cases are possible:\n\n        1. The graph passed to the constructor is bipartite. In this case, a 2-coloring is computed.\n\n        2. The graph isn't bipartite. In that case, the coloring is chosen to be the trivial one. Every node has a unique number, which is its color. \n\n        Returns:\n            (dict): A dictionnary {node: color} that associates a color to each node.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n            &gt;&gt;&gt; qw.color()\n            {0: 1, 1: 0, 3: 0, 2: 1}\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))\n            &gt;&gt;&gt; qw.color()\n            {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n\n        \"\"\"\n        return deepcopy(self.__color)\n\n    def set_color(self, color):\n        \"\"\" Modifies the coloring of the graph. \n        Since the coloring is essential to the definition of the QW, modifying it will reinitialize the inner state to the diagonal one. Essentially, the method set_color calls the method reset.\n\n        Args:\n            color (dict): The new coloring for the underlying graph. Must be a dictionnary node:color\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))\n            &gt;&gt;&gt; qw.color()\n            {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n            &gt;&gt;&gt; qw.set_color(nx.greedy_color(qw.graph()))\n            &gt;&gt;&gt; qw.color()\n            {0: 0, 1: 1, 2: 0, 3: 1, 4: 2}\n        \"\"\"\n        self.__color = color\n        nx.set_node_attributes(self.__G, self.__color, \"color\")\n        self.__initalize_rust_object()\n\n\n    def state(self, edges = None):\n        \"\"\" Return the amplitudes of one/several/every edges.\n\n        For an edge (u,v), the amplitudes $\\psi_{u,v}^+$ and $\\psi_{u,v}^-$ will be returned in the form of a numpy array.\n\n        Args:\n            edges (list, optional): The list of edges for which we want to extract the amplitudes. If None, all the edges are extracted.\n\n        Returns:\n            (dict): A dictionnary edge:amplitudes where the amplitudes are complex numpy arrays of dimension 2.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n            &gt;&gt;&gt; qw.state()\n            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n            &gt;&gt;&gt; qw.state(qw.edges()[0:2])\n            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n             (0, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n        \"\"\"\n        dic = {}\n        if type(edges) == type(None):\n            edges = self.__edges\n        for e in edges:\n            i = self.__get_edge_index(e)[1]\n            dic[e] = np.array([self.__qwf.state[2*i],self.__qwf.state[2*i+1]],dtype=complex)\n        return dic\n\n    def set_state(self, new_state):\n        \"\"\" Change the inner state (i.e. the amplitudes for every edges).\n\n        For an edge (u,v), the amplitudes $\\psi_{u,v}^+$ and $\\psi_{u,v}^-$ will be modified according to the argument.\n        If the new state is not normalized, this method will automatically normalize it.\n\n        Args:\n            new_state (dict): A dictionnary of the form edge: amplitudes. Amplitudes must be numpy arrays or lists of dimension 2.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n            &gt;&gt;&gt; qw.state()\n            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n            &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n            &gt;&gt;&gt; qw.state()\n            {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),\n             (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),\n             (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),\n             (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}\n        \"\"\"\n        s = np.sqrt(sum([abs(new_state[e][0])**2 + abs(new_state[e][1])**2 for e in new_state]))\n        state = np.array([0]*2*self.__E,dtype=complex)\n        for i in range(self.__E):\n            state[2*i] = new_state[self.__edges[i]][0]/s\n            state[2*i+1] = new_state[self.__edges[i]][1]/s\n        self.__qwf.state = state\n\n\n    def reset(self):\n        \"\"\" Reset the state to a diagonal one and reset the current step to 0.\n        Do not return anything.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n            &gt;&gt;&gt; qw.state()\n            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n            &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n            &gt;&gt;&gt; qw.state()\n            {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),\n             (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),\n             (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),\n             (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}\n            &gt;&gt;&gt; qw.reset()\n            &gt;&gt;&gt; qw.state()\n            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n\n        \"\"\"\n        self.step=0\n        self.__qwf.reset()\n\n\n    def __get_edge_index(self, searched):\n        if self.__search_nodes:\n            edge = self.__virtual_edges[searched]\n            index = self.__index[edge]\n        else:\n            edge = searched\n            index = self.__index[edge]\n        return edge,index\n\n\n    def get_proba(self, searched):\n        \"\"\" Returns the probability to measure on of the searched element.\n\n        Args:   \n            searched (list of edge): The list of marked edges. Every element of the list must be an edge label (all of them are listed in `qw.edges`).\n\n        Returns:\n            (float): The probability of measuring any of the marked edges.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.get_proba([qw.edges()[0]])\n            0.1666666666666667\n            &gt;&gt;&gt; qw.get_proba([qw.edges()[0],qw.edges()[1]])\n            0.3333333333333334\n            &gt;&gt;&gt; qw.get_proba(qw.edges())\n            1.\n        \"\"\"\n        return self.__qwf.get_proba([self.__get_edge_index(i)[1] for i in searched])\n\n    def run(self, C, R, searched=[], ticks=1):\n        \"\"\" Run the simulation with coin `C`, oracle `R` for ticks steps and with searched elements `search`.\n        Nothing will be returned but the inner state will be modified inplace.\n\n        Args:\n            C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.\n            R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.\n            searched (list, optional): The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.\n            ticks (int, optional): The number of time steps.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(6))\n            &gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})\n            &gt;&gt;&gt; [qw.get_proba([e]) for e in qw.edges()]\n            [0.0, 0.0, 0.0, 1.0, 0.0, 0.0]\n            &gt;&gt;&gt; qw.run(coins.H,coins.I,ticks=3)\n            &gt;&gt;&gt; [np.round(qw.get_proba([e]),3) for e in qw.edges()]\n            [0.0, 0.25, 0.625, 0.0, 0.125, 0.0]\n        \"\"\"\n        self.__qwf.run(C,R,ticks,[self.__get_edge_index(i)[1] for i in searched])\n        self.step+=ticks\n\n    def search(self, C, R, searched=[], ticks=1, progress=False):\n        \"\"\" Run the simulation with coin `C`, oracle `R` for ticks steps and with searched elements `searched`.\n\n        This method does the same thing than `run`, but returns the probability of success at every steps. For every marked element m, the probability of measuring m at every step is returned.\n\n        Args:\n            C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.\n            R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.\n            searched (list, optional): The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.\n            ticks (int, optional): The number of time steps.\n            progress (bool, optional): If True, a tqdm progress bar will be displayed.\n\n        Returns:\n            (pandas.DataFrame): A dataframe containing probabilities fo measuring marked positions. The column \"step\" denote the step number (or epoch) of the dynamic. For each marked element `m`, the column `m` denotes the probability of measuring `m` at any given step. The column `p_succ` denotes the probability of measuring any marked elements and is essentially the sum of all the other colmuns excepted \"step\".\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))\n            &gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.edges()[0:4],ticks=10))\n                step    p_succ    (0, 1)    (0, 2)    (0, 3)    (0, 4)\n            0      0  0.000808  0.000202  0.000202  0.000202  0.000202\n            1      1  0.003880  0.000994  0.000978  0.000962  0.000946\n            2      2  0.009113  0.002467  0.002337  0.002214  0.002095\n            3      3  0.013043  0.003875  0.003441  0.003044  0.002683\n            4      4  0.013292  0.004433  0.003617  0.002918  0.002324\n            5      5  0.010471  0.003820  0.002892  0.002162  0.001596\n            6      6  0.007487  0.002620  0.002011  0.001579  0.001277\n            7      7  0.005653  0.001645  0.001455  0.001324  0.001228\n            8      8  0.004657  0.001321  0.001212  0.001107  0.001017\n            9      9  0.004065  0.001494  0.001105  0.000824  0.000641\n            10    10  0.004440  0.001913  0.001226  0.000784  0.000517\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100),search_nodes=True)\n            &gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.nodes()[0:4],ticks=10))\n                step    p_succ         0         1         2         3\n            0      0  0.000792  0.000198  0.000198  0.000198  0.000198\n            1      1  0.000746  0.000198  0.000190  0.000182  0.000175\n            2      2  0.003557  0.000978  0.000917  0.000859  0.000803\n            3      3  0.000890  0.000280  0.000237  0.000201  0.000172\n            4      4  0.000097  0.000023  0.000020  0.000023  0.000031\n            5      5  0.000320  0.000072  0.000079  0.000084  0.000086\n            6      6  0.004178  0.001147  0.001087  0.001014  0.000930\n            7      7  0.002613  0.000864  0.000713  0.000577  0.000459\n            8      8  0.002197  0.000817  0.000607  0.000446  0.000327\n            9      9  0.002605  0.000897  0.000695  0.000554  0.000458\n            10    10  0.000085  0.000036  0.000022  0.000015  0.000012\n\n        \"\"\"\n        p = {}\n        p[\"step\"] = [self.step]\n        p[\"p_succ\"] = [self.get_proba(searched)]\n        for i in searched:\n            p[i] = [self.get_proba([i])]\n\n        for i in (tqdm(range(ticks))) if progress else (range(ticks)):\n            self.run(C,R,ticks=1,searched=searched)\n\n            p[\"p_succ\"].append(self.get_proba(searched))\n            p[\"step\"].append(self.step)\n            for i in searched:\n                p[i].append(self.get_proba([i]))\n        return pd.DataFrame(p)\n\n    def get_unitary(self, C, R, searched=[], dataframe=False, progress=False):\n        \"\"\" For a given coin, oracle and set of searched edges, compute and return the unitary U coresponding to one step of the QW.\n\n        This method **do not** change the state of the QW.\n\n        Args:\n            C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.\n            R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.\n            searched (list, optional): The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.\n            dataframe (bool, optional): If True, the result will be a pandas dataframe instead of a numpy array. \n            progress (bool, optional): If True, a tqdm progress bar will be displayed.\n\n        Returns:\n            (numpy array or pandas dataframe): The unitary operator coresponding to one step of the dynamic. If dataframe is set to True, a pandas dataframe will be returned instead.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(3))\n            &gt;&gt;&gt; qw.get_unitary(coins.H,coins.I)\n            array([[ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,\n                     0.70710678+0.j,  0.        +0.j,  0.        +0.j],\n                   [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n                     0.        +0.j,  0.70710678+0.j,  0.70710678+0.j],\n                   [ 0.70710678+0.j,  0.70710678+0.j,  0.        +0.j,\n                     0.        +0.j,  0.        +0.j,  0.        +0.j],\n                   [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n                     0.        +0.j,  0.70710678+0.j, -0.70710678+0.j],\n                   [ 0.70710678+0.j, -0.70710678+0.j,  0.        +0.j,\n                     0.        +0.j,  0.        +0.j,  0.        +0.j],\n                   [ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,\n                    -0.70710678+0.j,  0.        +0.j,  0.        +0.j]])\n        \"\"\"\n        old_state = copy.deepcopy(self.__qwf.state)\n        old_step = self.step\n        U = []\n        for i in (tqdm(range(2*self.__E),ncols=100)) if progress else (range(2*self.__E)):\n            self.__qwf.state = np.array([int(i==j) for j in range(2*self.__E)],dtype=complex)\n            self.run(C, R, ticks=1, searched=searched)\n            U.append(copy.deepcopy(self.__qwf.state))\n        self.__qwf.state = old_state\n        self.step=old_step\n        U = np.array(U,dtype=complex).transpose()\n        if dataframe:\n            df = pd.DataFrame(U, index=self.__amplitude_labels, columns=self.__amplitude_labels)\n            return df\n        else:\n            return U\n\n    def get_T_P(self, C, R, searched=[], waiting=10):\n        \"\"\" Computes the hitting time and probability of success for a given QW. \n\n        The waiting parameter is used to accumalate informations about the signal (recommended to be at least 10).\n\n        In details, this algorithm look at the time serie of the probability of success $p(t)$. \n        At any time step $t$, we define $T_{max}(t) = \\\\underset{{t' \\\\leq t}}{\\\\mathrm{argmax }}\\\\; p(t')$ and $T_{min}(t) = \\\\underset{{t' \\\\leq t}}{\\\\mathrm{argmin }} \\\\; p(t')$.\n\n        The algorithms computes the series $p(t)$, $T_{max}(t)$, $T_{min}(t)$ and stop when it encounters `t&gt;waiting` such that $p(t)&lt;\\\\frac{p\\\\left(T_{max}(t)\\\\right)+p\\\\left(T_{max}(t)\\\\right)}{2}$. \n        It then returns $T_{max}(t), p\\\\left(T_{max}(t)\\\\right)$.\n\n        **Warning:** This function will reset the state of the QW.\n\n        Args:\n            C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.\n            R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.\n            searched (list, optional): The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.\n            waiting (int, optional): The waiting time for the algorithm. Must be smaller than the hitting time.\n\n        Returns:\n            (int*float): T:int,P:float respectively the hitting time and probability of success.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))\n            &gt;&gt;&gt; qw.get_T_P(coins.X,-coins.X,searched=qw.edges()[0:4])\n            (28, 0.9565191408575295)\n        \"\"\"\n\n        self.reset()\n        ret = self.__qwf.carac(C,R,[self.__get_edge_index(i)[1] for i in searched],waiting)\n        self.reset()\n        return ret\n</code></pre>"},{"location":"qwsearch/#getters","title":"Getters","text":""},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.graph","title":"<code>graph(self)</code>","text":"<p>Returns the underlying graph.</p> <p>Returns:</p> Type Description <code>(networkx.Graph)</code> <p>The underlying graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.graph()\n&lt;networkx.classes.graph.Graph at 0x7bd045d53c70&gt;\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def graph(self):\n    \"\"\" Returns the underlying graph.\n\n    Returns:\n        (networkx.Graph): The underlying graph.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.graph()\n        &lt;networkx.classes.graph.Graph at 0x7bd045d53c70&gt;\n\n    \"\"\"\n    return deepcopy(self.__G)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.nodes","title":"<code>nodes(self)</code>","text":"<p>Returns the list of nodes. Convenient when declaring which nodes are marked.</p> <p>Returns:</p> Type Description <code>(list of node)</code> <p>The list of nodes of the underlying graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.nodes()\n[0, 1, 2, 3]\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def nodes(self):\n    \"\"\" Returns the list of nodes. Convenient when declaring which nodes are marked.\n\n    Returns:\n        (list of node): The list of nodes of the underlying graph.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.nodes()\n        [0, 1, 2, 3]\n\n    \"\"\"\n    return deepcopy(self.__nodes)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.edges","title":"<code>edges(self)</code>","text":"<p>Returns the list of edges. Convenient when declaring which edges are marked.</p> <p>Returns:</p> Type Description <code>(list of edge)</code> <p>The list of edges of the underlying graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.edges()\n[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def edges(self):\n    \"\"\" Returns the list of edges. Convenient when declaring which edges are marked.\n\n    Returns:\n        (list of edge): The list of edges of the underlying graph.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.edges()\n        [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n\n    \"\"\"\n    return deepcopy(self.__edges)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.virtual_edges","title":"<code>virtual_edges(self)</code>","text":"<p>Returns a dictionnary that associates its virtual edge to each node. This dictionnary is empty when the object has been built with <code>search_nodes==False</code> since there are no virtual edges in that case.</p> <p>Returns:</p> Type Description <code>(dict)</code> <p>A dictionnary {node: edge} that associates each node to its virtual edge.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.virtual_edges()\n{}\n&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4),search_nodes=True)\n&gt;&gt;&gt; qw.virtual_edges()\n{0: (0, 'new_node0'),\n 1: (1, 'new_node1'),\n 2: (2, 'new_node2'),\n 3: (3, 'new_node3')}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def virtual_edges(self):\n    \"\"\" Returns a dictionnary that associates its virtual edge to each node. This dictionnary is empty when the object has been built with `search_nodes==False` since there are no virtual edges in that case.\n\n    Returns:\n        (dict): A dictionnary {node: edge} that associates each node to its virtual edge.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.virtual_edges()\n        {}\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4),search_nodes=True)\n        &gt;&gt;&gt; qw.virtual_edges()\n        {0: (0, 'new_node0'),\n         1: (1, 'new_node1'),\n         2: (2, 'new_node2'),\n         3: (3, 'new_node3')}\n\n    \"\"\"\n    return deepcopy(self.__virtual_edges)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.color","title":"<code>color(self)</code>","text":"<p>Returns the coloring of the underlying graph. This coloring is essential for the QW to be well defined.</p> <p>The coloring is calculated when the object is built. Two cases are possible:</p> <ol> <li> <p>The graph passed to the constructor is bipartite. In this case, a 2-coloring is computed.</p> </li> <li> <p>The graph isn't bipartite. In that case, the coloring is chosen to be the trivial one. Every node has a unique number, which is its color. </p> </li> </ol> <p>Returns:</p> Type Description <code>(dict)</code> <p>A dictionnary {node: color} that associates a color to each node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n&gt;&gt;&gt; qw.color()\n{0: 1, 1: 0, 3: 0, 2: 1}\n&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))\n&gt;&gt;&gt; qw.color()\n{0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def color(self):\n    \"\"\" Returns the coloring of the underlying graph. This coloring is essential for the QW to be well defined.\n\n    The coloring is calculated when the object is built. Two cases are possible:\n\n    1. The graph passed to the constructor is bipartite. In this case, a 2-coloring is computed.\n\n    2. The graph isn't bipartite. In that case, the coloring is chosen to be the trivial one. Every node has a unique number, which is its color. \n\n    Returns:\n        (dict): A dictionnary {node: color} that associates a color to each node.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n        &gt;&gt;&gt; qw.color()\n        {0: 1, 1: 0, 3: 0, 2: 1}\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))\n        &gt;&gt;&gt; qw.color()\n        {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n\n    \"\"\"\n    return deepcopy(self.__color)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.state","title":"<code>state(self, edges=None)</code>","text":"<p>Return the amplitudes of one/several/every edges.</p> <p>For an edge (u,v), the amplitudes \\(\\psi_{u,v}^+\\) and \\(\\psi_{u,v}^-\\) will be returned in the form of a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>list</code> <p>The list of edges for which we want to extract the amplitudes. If None, all the edges are extracted.</p> <code>None</code> <p>Returns:</p> Type Description <code>(dict)</code> <p>A dictionnary edge:amplitudes where the amplitudes are complex numpy arrays of dimension 2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n&gt;&gt;&gt; qw.state()\n{(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n&gt;&gt;&gt; qw.state(qw.edges()[0:2])\n{(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n (0, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def state(self, edges = None):\n    \"\"\" Return the amplitudes of one/several/every edges.\n\n    For an edge (u,v), the amplitudes $\\psi_{u,v}^+$ and $\\psi_{u,v}^-$ will be returned in the form of a numpy array.\n\n    Args:\n        edges (list, optional): The list of edges for which we want to extract the amplitudes. If None, all the edges are extracted.\n\n    Returns:\n        (dict): A dictionnary edge:amplitudes where the amplitudes are complex numpy arrays of dimension 2.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n        &gt;&gt;&gt; qw.state()\n        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n        &gt;&gt;&gt; qw.state(qw.edges()[0:2])\n        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n         (0, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n    \"\"\"\n    dic = {}\n    if type(edges) == type(None):\n        edges = self.__edges\n    for e in edges:\n        i = self.__get_edge_index(e)[1]\n        dic[e] = np.array([self.__qwf.state[2*i],self.__qwf.state[2*i+1]],dtype=complex)\n    return dic\n</code></pre>"},{"location":"qwsearch/#setters","title":"Setters","text":""},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.set_state","title":"<code>set_state(self, new_state)</code>","text":"<p>Change the inner state (i.e. the amplitudes for every edges).</p> <p>For an edge (u,v), the amplitudes \\(\\psi_{u,v}^+\\) and \\(\\psi_{u,v}^-\\) will be modified according to the argument. If the new state is not normalized, this method will automatically normalize it.</p> <p>Parameters:</p> Name Type Description Default <code>new_state</code> <code>dict</code> <p>A dictionnary of the form edge: amplitudes. Amplitudes must be numpy arrays or lists of dimension 2.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n&gt;&gt;&gt; qw.state()\n{(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n&gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n&gt;&gt;&gt; qw.state()\n{(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),\n (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),\n (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),\n (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def set_state(self, new_state):\n    \"\"\" Change the inner state (i.e. the amplitudes for every edges).\n\n    For an edge (u,v), the amplitudes $\\psi_{u,v}^+$ and $\\psi_{u,v}^-$ will be modified according to the argument.\n    If the new state is not normalized, this method will automatically normalize it.\n\n    Args:\n        new_state (dict): A dictionnary of the form edge: amplitudes. Amplitudes must be numpy arrays or lists of dimension 2.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n        &gt;&gt;&gt; qw.state()\n        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n        &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n        &gt;&gt;&gt; qw.state()\n        {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),\n         (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),\n         (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),\n         (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}\n    \"\"\"\n    s = np.sqrt(sum([abs(new_state[e][0])**2 + abs(new_state[e][1])**2 for e in new_state]))\n    state = np.array([0]*2*self.__E,dtype=complex)\n    for i in range(self.__E):\n        state[2*i] = new_state[self.__edges[i]][0]/s\n        state[2*i+1] = new_state[self.__edges[i]][1]/s\n    self.__qwf.state = state\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.set_color","title":"<code>set_color(self, color)</code>","text":"<p>Modifies the coloring of the graph.  Since the coloring is essential to the definition of the QW, modifying it will reinitialize the inner state to the diagonal one. Essentially, the method set_color calls the method reset.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>dict</code> <p>The new coloring for the underlying graph. Must be a dictionnary node:color</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))\n&gt;&gt;&gt; qw.color()\n{0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n&gt;&gt;&gt; qw.set_color(nx.greedy_color(qw.graph()))\n&gt;&gt;&gt; qw.color()\n{0: 0, 1: 1, 2: 0, 3: 1, 4: 2}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def set_color(self, color):\n    \"\"\" Modifies the coloring of the graph. \n    Since the coloring is essential to the definition of the QW, modifying it will reinitialize the inner state to the diagonal one. Essentially, the method set_color calls the method reset.\n\n    Args:\n        color (dict): The new coloring for the underlying graph. Must be a dictionnary node:color\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))\n        &gt;&gt;&gt; qw.color()\n        {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n        &gt;&gt;&gt; qw.set_color(nx.greedy_color(qw.graph()))\n        &gt;&gt;&gt; qw.color()\n        {0: 0, 1: 1, 2: 0, 3: 1, 4: 2}\n    \"\"\"\n    self.__color = color\n    nx.set_node_attributes(self.__G, self.__color, \"color\")\n    self.__initalize_rust_object()\n</code></pre>"},{"location":"qwsearch/#simulation","title":"Simulation","text":""},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.run","title":"<code>run(self, C, R, searched=[], ticks=1)</code>","text":"<p>Run the simulation with coin <code>C</code>, oracle <code>R</code> for ticks steps and with searched elements <code>search</code>. Nothing will be returned but the inner state will be modified inplace.</p> <p>Parameters:</p> Name Type Description Default <code>C</code> <code>numpy.array of complex</code> <p>The coin defined as a 2x2 numpy array of complex.</p> required <code>R</code> <code>numpy.array of complex</code> <p>The oracle defined as a 2x2 numpy array of complex.</p> required <code>searched</code> <code>list</code> <p>The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.</p> <code>[]</code> <code>ticks</code> <code>int</code> <p>The number of time steps.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(6))\n&gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})\n&gt;&gt;&gt; [qw.get_proba([e]) for e in qw.edges()]\n[0.0, 0.0, 0.0, 1.0, 0.0, 0.0]\n&gt;&gt;&gt; qw.run(coins.H,coins.I,ticks=3)\n&gt;&gt;&gt; [np.round(qw.get_proba([e]),3) for e in qw.edges()]\n[0.0, 0.25, 0.625, 0.0, 0.125, 0.0]\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def run(self, C, R, searched=[], ticks=1):\n    \"\"\" Run the simulation with coin `C`, oracle `R` for ticks steps and with searched elements `search`.\n    Nothing will be returned but the inner state will be modified inplace.\n\n    Args:\n        C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.\n        R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.\n        searched (list, optional): The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.\n        ticks (int, optional): The number of time steps.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(6))\n        &gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})\n        &gt;&gt;&gt; [qw.get_proba([e]) for e in qw.edges()]\n        [0.0, 0.0, 0.0, 1.0, 0.0, 0.0]\n        &gt;&gt;&gt; qw.run(coins.H,coins.I,ticks=3)\n        &gt;&gt;&gt; [np.round(qw.get_proba([e]),3) for e in qw.edges()]\n        [0.0, 0.25, 0.625, 0.0, 0.125, 0.0]\n    \"\"\"\n    self.__qwf.run(C,R,ticks,[self.__get_edge_index(i)[1] for i in searched])\n    self.step+=ticks\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.search","title":"<code>search(self, C, R, searched=[], ticks=1, progress=False)</code>","text":"<p>Run the simulation with coin <code>C</code>, oracle <code>R</code> for ticks steps and with searched elements <code>searched</code>.</p> <p>This method does the same thing than <code>run</code>, but returns the probability of success at every steps. For every marked element m, the probability of measuring m at every step is returned.</p> <p>Parameters:</p> Name Type Description Default <code>C</code> <code>numpy.array of complex</code> <p>The coin defined as a 2x2 numpy array of complex.</p> required <code>R</code> <code>numpy.array of complex</code> <p>The oracle defined as a 2x2 numpy array of complex.</p> required <code>searched</code> <code>list</code> <p>The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.</p> <code>[]</code> <code>ticks</code> <code>int</code> <p>The number of time steps.</p> <code>1</code> <code>progress</code> <code>bool</code> <p>If True, a tqdm progress bar will be displayed.</p> <code>False</code> <p>Returns:</p> Type Description <code>(pandas.DataFrame)</code> <p>A dataframe containing probabilities fo measuring marked positions. The column \"step\" denote the step number (or epoch) of the dynamic. For each marked element <code>m</code>, the column <code>m</code> denotes the probability of measuring <code>m</code> at any given step. The column <code>p_succ</code> denotes the probability of measuring any marked elements and is essentially the sum of all the other colmuns excepted \"step\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))\n&gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.edges()[0:4],ticks=10))\n    step    p_succ    (0, 1)    (0, 2)    (0, 3)    (0, 4)\n0      0  0.000808  0.000202  0.000202  0.000202  0.000202\n1      1  0.003880  0.000994  0.000978  0.000962  0.000946\n2      2  0.009113  0.002467  0.002337  0.002214  0.002095\n3      3  0.013043  0.003875  0.003441  0.003044  0.002683\n4      4  0.013292  0.004433  0.003617  0.002918  0.002324\n5      5  0.010471  0.003820  0.002892  0.002162  0.001596\n6      6  0.007487  0.002620  0.002011  0.001579  0.001277\n7      7  0.005653  0.001645  0.001455  0.001324  0.001228\n8      8  0.004657  0.001321  0.001212  0.001107  0.001017\n9      9  0.004065  0.001494  0.001105  0.000824  0.000641\n10    10  0.004440  0.001913  0.001226  0.000784  0.000517\n&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100),search_nodes=True)\n&gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.nodes()[0:4],ticks=10))\n    step    p_succ         0         1         2         3\n0      0  0.000792  0.000198  0.000198  0.000198  0.000198\n1      1  0.000746  0.000198  0.000190  0.000182  0.000175\n2      2  0.003557  0.000978  0.000917  0.000859  0.000803\n3      3  0.000890  0.000280  0.000237  0.000201  0.000172\n4      4  0.000097  0.000023  0.000020  0.000023  0.000031\n5      5  0.000320  0.000072  0.000079  0.000084  0.000086\n6      6  0.004178  0.001147  0.001087  0.001014  0.000930\n7      7  0.002613  0.000864  0.000713  0.000577  0.000459\n8      8  0.002197  0.000817  0.000607  0.000446  0.000327\n9      9  0.002605  0.000897  0.000695  0.000554  0.000458\n10    10  0.000085  0.000036  0.000022  0.000015  0.000012\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def search(self, C, R, searched=[], ticks=1, progress=False):\n    \"\"\" Run the simulation with coin `C`, oracle `R` for ticks steps and with searched elements `searched`.\n\n    This method does the same thing than `run`, but returns the probability of success at every steps. For every marked element m, the probability of measuring m at every step is returned.\n\n    Args:\n        C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.\n        R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.\n        searched (list, optional): The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.\n        ticks (int, optional): The number of time steps.\n        progress (bool, optional): If True, a tqdm progress bar will be displayed.\n\n    Returns:\n        (pandas.DataFrame): A dataframe containing probabilities fo measuring marked positions. The column \"step\" denote the step number (or epoch) of the dynamic. For each marked element `m`, the column `m` denotes the probability of measuring `m` at any given step. The column `p_succ` denotes the probability of measuring any marked elements and is essentially the sum of all the other colmuns excepted \"step\".\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))\n        &gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.edges()[0:4],ticks=10))\n            step    p_succ    (0, 1)    (0, 2)    (0, 3)    (0, 4)\n        0      0  0.000808  0.000202  0.000202  0.000202  0.000202\n        1      1  0.003880  0.000994  0.000978  0.000962  0.000946\n        2      2  0.009113  0.002467  0.002337  0.002214  0.002095\n        3      3  0.013043  0.003875  0.003441  0.003044  0.002683\n        4      4  0.013292  0.004433  0.003617  0.002918  0.002324\n        5      5  0.010471  0.003820  0.002892  0.002162  0.001596\n        6      6  0.007487  0.002620  0.002011  0.001579  0.001277\n        7      7  0.005653  0.001645  0.001455  0.001324  0.001228\n        8      8  0.004657  0.001321  0.001212  0.001107  0.001017\n        9      9  0.004065  0.001494  0.001105  0.000824  0.000641\n        10    10  0.004440  0.001913  0.001226  0.000784  0.000517\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100),search_nodes=True)\n        &gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.nodes()[0:4],ticks=10))\n            step    p_succ         0         1         2         3\n        0      0  0.000792  0.000198  0.000198  0.000198  0.000198\n        1      1  0.000746  0.000198  0.000190  0.000182  0.000175\n        2      2  0.003557  0.000978  0.000917  0.000859  0.000803\n        3      3  0.000890  0.000280  0.000237  0.000201  0.000172\n        4      4  0.000097  0.000023  0.000020  0.000023  0.000031\n        5      5  0.000320  0.000072  0.000079  0.000084  0.000086\n        6      6  0.004178  0.001147  0.001087  0.001014  0.000930\n        7      7  0.002613  0.000864  0.000713  0.000577  0.000459\n        8      8  0.002197  0.000817  0.000607  0.000446  0.000327\n        9      9  0.002605  0.000897  0.000695  0.000554  0.000458\n        10    10  0.000085  0.000036  0.000022  0.000015  0.000012\n\n    \"\"\"\n    p = {}\n    p[\"step\"] = [self.step]\n    p[\"p_succ\"] = [self.get_proba(searched)]\n    for i in searched:\n        p[i] = [self.get_proba([i])]\n\n    for i in (tqdm(range(ticks))) if progress else (range(ticks)):\n        self.run(C,R,ticks=1,searched=searched)\n\n        p[\"p_succ\"].append(self.get_proba(searched))\n        p[\"step\"].append(self.step)\n        for i in searched:\n            p[i].append(self.get_proba([i]))\n    return pd.DataFrame(p)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.get_T_P","title":"<code>get_T_P(self, C, R, searched=[], waiting=10)</code>","text":"<p>Computes the hitting time and probability of success for a given QW. </p> <p>The waiting parameter is used to accumalate informations about the signal (recommended to be at least 10).</p> <p>In details, this algorithm look at the time serie of the probability of success \\(p(t)\\).  At any time step \\(t\\), we define \\(T_{max}(t) = \\underset{{t' \\leq t}}{\\mathrm{argmax }}\\; p(t')\\) and \\(T_{min}(t) = \\underset{{t' \\leq t}}{\\mathrm{argmin }} \\; p(t')\\).</p> <p>The algorithms computes the series \\(p(t)\\), \\(T_{max}(t)\\), \\(T_{min}(t)\\) and stop when it encounters <code>t&gt;waiting</code> such that \\(p(t)&lt;\\frac{p\\left(T_{max}(t)\\right)+p\\left(T_{max}(t)\\right)}{2}\\).  It then returns \\(T_{max}(t), p\\left(T_{max}(t)\\right)\\).</p> <p>Warning: This function will reset the state of the QW.</p> <p>Parameters:</p> Name Type Description Default <code>C</code> <code>numpy.array of complex</code> <p>The coin defined as a 2x2 numpy array of complex.</p> required <code>R</code> <code>numpy.array of complex</code> <p>The oracle defined as a 2x2 numpy array of complex.</p> required <code>searched</code> <code>list</code> <p>The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.</p> <code>[]</code> <code>waiting</code> <code>int</code> <p>The waiting time for the algorithm. Must be smaller than the hitting time.</p> <code>10</code> <p>Returns:</p> Type Description <code>(int*float)</code> <p>T:int,P:float respectively the hitting time and probability of success.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))\n&gt;&gt;&gt; qw.get_T_P(coins.X,-coins.X,searched=qw.edges()[0:4])\n(28, 0.9565191408575295)\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def get_T_P(self, C, R, searched=[], waiting=10):\n    \"\"\" Computes the hitting time and probability of success for a given QW. \n\n    The waiting parameter is used to accumalate informations about the signal (recommended to be at least 10).\n\n    In details, this algorithm look at the time serie of the probability of success $p(t)$. \n    At any time step $t$, we define $T_{max}(t) = \\\\underset{{t' \\\\leq t}}{\\\\mathrm{argmax }}\\\\; p(t')$ and $T_{min}(t) = \\\\underset{{t' \\\\leq t}}{\\\\mathrm{argmin }} \\\\; p(t')$.\n\n    The algorithms computes the series $p(t)$, $T_{max}(t)$, $T_{min}(t)$ and stop when it encounters `t&gt;waiting` such that $p(t)&lt;\\\\frac{p\\\\left(T_{max}(t)\\\\right)+p\\\\left(T_{max}(t)\\\\right)}{2}$. \n    It then returns $T_{max}(t), p\\\\left(T_{max}(t)\\\\right)$.\n\n    **Warning:** This function will reset the state of the QW.\n\n    Args:\n        C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.\n        R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.\n        searched (list, optional): The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.\n        waiting (int, optional): The waiting time for the algorithm. Must be smaller than the hitting time.\n\n    Returns:\n        (int*float): T:int,P:float respectively the hitting time and probability of success.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))\n        &gt;&gt;&gt; qw.get_T_P(coins.X,-coins.X,searched=qw.edges()[0:4])\n        (28, 0.9565191408575295)\n    \"\"\"\n\n    self.reset()\n    ret = self.__qwf.carac(C,R,[self.__get_edge_index(i)[1] for i in searched],waiting)\n    self.reset()\n    return ret\n</code></pre>"},{"location":"qwsearch/#others","title":"Others","text":""},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.reset","title":"<code>reset(self)</code>","text":"<p>Reset the state to a diagonal one and reset the current step to 0. Do not return anything.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n&gt;&gt;&gt; qw.state()\n{(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n&gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n&gt;&gt;&gt; qw.state()\n{(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),\n (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),\n (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),\n (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}\n&gt;&gt;&gt; qw.reset()\n&gt;&gt;&gt; qw.state()\n{(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def reset(self):\n    \"\"\" Reset the state to a diagonal one and reset the current step to 0.\n    Do not return anything.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n        &gt;&gt;&gt; qw.state()\n        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n        &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n        &gt;&gt;&gt; qw.state()\n        {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),\n         (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),\n         (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),\n         (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}\n        &gt;&gt;&gt; qw.reset()\n        &gt;&gt;&gt; qw.state()\n        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n\n    \"\"\"\n    self.step=0\n    self.__qwf.reset()\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.get_proba","title":"<code>get_proba(self, searched)</code>","text":"<p>Returns the probability to measure on of the searched element.</p> <p>!!! args \" \"     searched (list of edge): The list of marked edges. Every element of the list must be an edge label (all of them are listed in <code>qw.edges</code>).</p> <p>Returns:</p> Type Description <code>(float)</code> <p>The probability of measuring any of the marked edges.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.get_proba([qw.edges()[0]])\n0.1666666666666667\n&gt;&gt;&gt; qw.get_proba([qw.edges()[0],qw.edges()[1]])\n0.3333333333333334\n&gt;&gt;&gt; qw.get_proba(qw.edges())\n1.\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def get_proba(self, searched):\n    \"\"\" Returns the probability to measure on of the searched element.\n\n    Args:   \n        searched (list of edge): The list of marked edges. Every element of the list must be an edge label (all of them are listed in `qw.edges`).\n\n    Returns:\n        (float): The probability of measuring any of the marked edges.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.get_proba([qw.edges()[0]])\n        0.1666666666666667\n        &gt;&gt;&gt; qw.get_proba([qw.edges()[0],qw.edges()[1]])\n        0.3333333333333334\n        &gt;&gt;&gt; qw.get_proba(qw.edges())\n        1.\n    \"\"\"\n    return self.__qwf.get_proba([self.__get_edge_index(i)[1] for i in searched])\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.get_unitary","title":"<code>get_unitary(self, C, R, searched=[], dataframe=False, progress=False)</code>","text":"<p>For a given coin, oracle and set of searched edges, compute and return the unitary U coresponding to one step of the QW.</p> <p>This method do not change the state of the QW.</p> <p>Parameters:</p> Name Type Description Default <code>C</code> <code>numpy.array of complex</code> <p>The coin defined as a 2x2 numpy array of complex.</p> required <code>R</code> <code>numpy.array of complex</code> <p>The oracle defined as a 2x2 numpy array of complex.</p> required <code>searched</code> <code>list</code> <p>The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.</p> <code>[]</code> <code>dataframe</code> <code>bool</code> <p>If True, the result will be a pandas dataframe instead of a numpy array. </p> <code>False</code> <code>progress</code> <code>bool</code> <p>If True, a tqdm progress bar will be displayed.</p> <code>False</code> <p>Returns:</p> Type Description <code>(numpy array or pandas dataframe)</code> <p>The unitary operator coresponding to one step of the dynamic. If dataframe is set to True, a pandas dataframe will be returned instead.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(3))\n&gt;&gt;&gt; qw.get_unitary(coins.H,coins.I)\narray([[ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,\n         0.70710678+0.j,  0.        +0.j,  0.        +0.j],\n       [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n         0.        +0.j,  0.70710678+0.j,  0.70710678+0.j],\n       [ 0.70710678+0.j,  0.70710678+0.j,  0.        +0.j,\n         0.        +0.j,  0.        +0.j,  0.        +0.j],\n       [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n         0.        +0.j,  0.70710678+0.j, -0.70710678+0.j],\n       [ 0.70710678+0.j, -0.70710678+0.j,  0.        +0.j,\n         0.        +0.j,  0.        +0.j,  0.        +0.j],\n       [ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,\n        -0.70710678+0.j,  0.        +0.j,  0.        +0.j]])\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def get_unitary(self, C, R, searched=[], dataframe=False, progress=False):\n    \"\"\" For a given coin, oracle and set of searched edges, compute and return the unitary U coresponding to one step of the QW.\n\n    This method **do not** change the state of the QW.\n\n    Args:\n        C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.\n        R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.\n        searched (list, optional): The list of marked elements. \"elements\" here means nodes if search_nodes was true when building the object, and means edges otherwise.\n        dataframe (bool, optional): If True, the result will be a pandas dataframe instead of a numpy array. \n        progress (bool, optional): If True, a tqdm progress bar will be displayed.\n\n    Returns:\n        (numpy array or pandas dataframe): The unitary operator coresponding to one step of the dynamic. If dataframe is set to True, a pandas dataframe will be returned instead.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(3))\n        &gt;&gt;&gt; qw.get_unitary(coins.H,coins.I)\n        array([[ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,\n                 0.70710678+0.j,  0.        +0.j,  0.        +0.j],\n               [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n                 0.        +0.j,  0.70710678+0.j,  0.70710678+0.j],\n               [ 0.70710678+0.j,  0.70710678+0.j,  0.        +0.j,\n                 0.        +0.j,  0.        +0.j,  0.        +0.j],\n               [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n                 0.        +0.j,  0.70710678+0.j, -0.70710678+0.j],\n               [ 0.70710678+0.j, -0.70710678+0.j,  0.        +0.j,\n                 0.        +0.j,  0.        +0.j,  0.        +0.j],\n               [ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,\n                -0.70710678+0.j,  0.        +0.j,  0.        +0.j]])\n    \"\"\"\n    old_state = copy.deepcopy(self.__qwf.state)\n    old_step = self.step\n    U = []\n    for i in (tqdm(range(2*self.__E),ncols=100)) if progress else (range(2*self.__E)):\n        self.__qwf.state = np.array([int(i==j) for j in range(2*self.__E)],dtype=complex)\n        self.run(C, R, ticks=1, searched=searched)\n        U.append(copy.deepcopy(self.__qwf.state))\n    self.__qwf.state = old_state\n    self.step=old_step\n    U = np.array(U,dtype=complex).transpose()\n    if dataframe:\n        df = pd.DataFrame(U, index=self.__amplitude_labels, columns=self.__amplitude_labels)\n        return df\n    else:\n        return U\n</code></pre>"}]}