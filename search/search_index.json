{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QWGraph Documentation","text":"<p>This is the documentation for the python package <code>qwgraph</code>.  This package's aim is to provide an efficient implementation of quantum walks on graphs. </p> <p>The quantum walk model implemented in this package follows the paper https://arxiv.org/abs/2310.10451 . This model is specifically designed for searching.</p> <p>Most of the critical functions of this package are implemented and compiled in rust, providing an efficient simulation.</p> <p>An example notebook can be found at https://github.com/mroget/qwgraph/blob/main/demo.ipynb</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#1-from-pip","title":"1. From pip","text":"<p><code>pip install qwgraph</code> For windows users, it might be necessary to install the rust toolchain cargo.</p>"},{"location":"#2-from-source","title":"2. From source","text":"<pre><code>git clone git@github.com:mroget/qwgraph.git\ncd qwgraph\n./build.sh\n</code></pre> <p>The script <code>build.sh</code> will compile everything and install it as a python package locally on your machine. It requires to install maturin via <code>pip install maturin</code></p>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li><code>numpy</code></li> <li><code>matplotlib</code></li> <li><code>networkx</code></li> <li><code>pandas</code></li> <li><code>tqdm</code></li> </ul>"},{"location":"coins/","title":"Coins","text":""},{"location":"coins/#qwgraph.coins.Cx","title":"<code>Cx</code>","text":"\\[ C_x = \\frac{1}{\\sqrt{2}}\\left(\\begin{matrix} 1 &amp; i \\\\ i &amp; 1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.Cy","title":"<code>Cy</code>","text":"\\[ C_y = \\frac{1}{\\sqrt{2}}\\left(\\begin{matrix} 1 &amp; -i \\\\ -i &amp; 1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.H","title":"<code>H</code>","text":"\\[ H = \\frac{1}{\\sqrt{2}}\\left(\\begin{matrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.I","title":"<code>I</code>","text":"\\[ I = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.S","title":"<code>S</code>","text":"\\[ S = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; i \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.T","title":"<code>T</code>","text":"\\[ T = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\frac{\\pi}{4}} \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.X","title":"<code>X</code>","text":"\\[ X = \\left(\\begin{matrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.Y","title":"<code>Y</code>","text":"\\[ Y = \\left(\\begin{matrix} 0 &amp; -i \\\\ i &amp; 0 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.Z","title":"<code>Z</code>","text":"\\[ Z = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\\\ \\end{matrix}\\right) \\]"},{"location":"coins/#qwgraph.coins.generalized_coin","title":"<code>generalized_coin(theta, phi, lbd)</code>","text":"<p>General coin</p> \\[ U(\\theta,\\phi,\\lambda) = \\left(\\begin{matrix} \\cos \\theta &amp; -e^{i\\lambda} \\sin \\theta \\\\ e^{i\\phi} \\sin \\theta &amp; e^{i(\\lambda+\\phi)} \\cos \\theta \\\\ \\end{matrix}\\right) \\] <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>The angle \\(\\theta\\).</p> required <code>phi</code> <code>float</code> <p>The angle \\(\\phi\\).</p> required <code>lbd</code> <code>float</code> <p>The angle \\(\\lambda\\).</p> required <p>Returns:</p> Type Description <code>(complex numpy array)</code> <p>\\(U(\\theta,\\phi,\\lambda)\\)</p> Source code in <code>qwgraph/coins.py</code> <pre><code>def generalized_coin(theta, phi, lbd):\n\t\"\"\" General coin\n\n\t$$\n\tU(\\\\theta,\\\\phi,\\\\lambda) = \\\\left(\\\\begin{matrix}\n\t\\\\cos \\\\theta &amp; -e^{i\\\\lambda} \\\\sin \\\\theta \\\\\\\\\n\te^{i\\\\phi} \\\\sin \\\\theta &amp; e^{i(\\\\lambda+\\\\phi)} \\\\cos \\\\theta \\\\\\\\\n\t\\\\end{matrix}\\\\right)\n\t$$\n\n\tArgs:\n\t\ttheta (float): The angle $\\\\theta$.\n\t\tphi (float): The angle $\\\\phi$.\n\t\tlbd (float): The angle $\\\\lambda$.\n\n\tReturns:\n\t\t(complex numpy array): $U(\\\\theta,\\\\phi,\\\\lambda)$\n\t\"\"\"\n\treturn np.array([[np.cos(theta) , -np.exp(1j*lbd)*np.sin(theta)],\n\t\t[np.exp(1j*phi)*np.sin(theta) , np.exp(1j*(lbd+phi))*np.cos(theta)]],dtype=complex)\n</code></pre>"},{"location":"coins/#qwgraph.coins.phase_shift","title":"<code>phase_shift(phi)</code>","text":"<p>Phase shift coin</p> \\[ P(\\phi) = \\left(\\begin{matrix} 1 &amp; 0 \\\\ 0 &amp; e^{i(\\phi)}\\\\ \\end{matrix}\\right) \\] <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>The angle \\(\\phi\\).</p> required <p>Returns:</p> Type Description <code>(complex numpy array)</code> <p>\\(P(\\phi)\\)</p> Source code in <code>qwgraph/coins.py</code> <pre><code>def phase_shift(phi):\n\t\"\"\" Phase shift coin\n\n\t$$\n\tP(\\\\phi) = \\\\left(\\\\begin{matrix}\n\t1 &amp; 0 \\\\\\\\\n\t0 &amp; e^{i(\\\\phi)}\\\\\\\\\n\t\\\\end{matrix}\\\\right)\n\t$$\n\n\tArgs:\n\t\tphi (float): The angle $\\\\phi$.\n\n\tReturns:\n\t\t(complex numpy array): $P(\\\\phi)$\n\t\"\"\"\n\treturn np.array([\n\t\t[1,0],\n\t\t[0,np.exp(1j*phi)]],dtype=complex)\n</code></pre>"},{"location":"qwsearch/","title":"Documentation for QWSearch","text":"<p>The class <code>qwgraph.QWSearch</code> contains everything to create and run quantum walks or search based quantum walks. In order to specify the underlying graph of the QW, the use of networkx is required.</p>"},{"location":"qwsearch/#qwsearch","title":"QWSearch","text":""},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch","title":"<code> QWSearch        </code>","text":"<p>The Quantum Walk based search class. An instance of this class will be a Quantum Walk on a given graph. Methods are provided to modify and access the QW state and to run the QWSearch.</p> <p>Both the Quantum Walk and searching process are described in https://arxiv.org/abs/2310.10451</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>networkx.Graph</code> <p>The graph on which the QW will be defined. Alternatively, graph can be a DiGraph. In that case, the polarity will follow the orientation of the edges. Self loops are ignored.</p> required <code>starify</code> <code>bool</code> <p>If True, the graph will be starified. </p> <code>False</code> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>class QWSearch:\n    \"\"\" \n    The Quantum Walk based search class. An instance of this class will be a Quantum Walk on a given graph.\n    Methods are provided to modify and access the QW state and to run the QWSearch.\n\n    Both the Quantum Walk and searching process are described in https://arxiv.org/abs/2310.10451\n\n    Args:\n        graph (networkx.Graph): The graph on which the QW will be defined. Alternatively, graph can be a DiGraph. In that case, the polarity will follow the orientation of the edges. Self loops are ignored.\n        starify (bool, optional): If True, the graph will be starified. \n    \"\"\"\n\n    ######################\n    ### Init functions ###\n    ######################\n    def __init__(self, graph, starify=False):\n        self._starified = starify\n\n        self._G = nx.Graph()\n        edges = list(graph.edges())\n        edges = [(u,v) for (u,v) in edges if u!=v]\n        self._G.add_edges_from(edges)\n\n        if self._starified:\n            self._virtual_edges = self._starify()\n        else:\n            self._virtual_edges = {}\n\n        self._edges = list(self._G.edges()) # List of edges\n        self._nodes = list(self._G.nodes()) # List of nodes\n        self._E = len(self._edges) # Number of edges\n        self._N = len(self._nodes) # Number of nodes\n        self._degrees = list(set(list(dict(nx.degree(self._G)).values())))\n        self._index = {self._edges[i]:i for i in range(len(self._edges))} # Index for edges\n        self._nodes_index = {self._nodes[i]:i  for i in range(self._N)} # Index for nodes\n\n        if nx.bipartite.is_bipartite(self._G):\n            color = nx.bipartite.color(self._G) # Coloring\n        else:\n            color = {self._nodes[i]:i for i in range(len(self._nodes))} # Coloring\n\n        self._polarity = {}\n        for (u,v) in self._edges:\n            self._polarity[(u,v)] = (\"-\" if color[u]&lt;color[v] else \"+\")\n            self._polarity[(v,u)] = (\"+\" if color[u]&lt;color[v] else \"-\")\n\n        self._initalize_rust_object()        \n\n\n    def _initalize_rust_object(self):\n        self._amplitude_labels = [\"\"]*2*self._E\n        wiring = [] # For any amplitude self.state[i], says to which node it is connected. Important for the scattering.\n        k = 0\n        for (i,j) in self._edges:\n            edge_label = str(i) + \",\" + str(j)\n            if self._polarity[(i,j)]==\"-\":\n                wiring.append(self._nodes_index[i])\n                wiring.append(self._nodes_index[j])\n            else:\n                wiring.append(self._nodes_index[j])\n                wiring.append(self._nodes_index[i])\n            self._amplitude_labels[k] = \"$\\psi_{\"+edge_label+\"}^-$\"\n            self._amplitude_labels[k+1] = \"$\\psi_{\"+edge_label+\"}^+$\"\n            k+=2\n\n\n        self._qwf = qwfast.QWFast(wiring,self._N,self._E)\n        self._around_nodes_indices = qwfast._get_indices_around_nodes(self._E,self._N,wiring)\n\n        self.reset()\n\n    def _starify(self):\n        nodes = copy.deepcopy(self._G.nodes())\n        s = {}\n        for i in nodes:\n            new_name = f\"*{i}\"\n            while new_name in self._G.nodes():\n                new_name = f\"*{new_name}\"\n            self._G.add_edge(i,new_name)\n            s[i] = (i,new_name)\n        return s\n\n\n\n\n\n\n\n    #####################\n    ### Getters graph ###\n    #####################\n    def nodes(self):\n        \"\"\" Returns the list of nodes. Convenient when declaring which nodes are marked.\n\n        Returns:\n            (list of node): The list of nodes of the underlying graph.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.nodes()\n            [0, 1, 2, 3]\n\n        \"\"\"\n        return deepcopy(self._nodes)\n\n    def edges(self):\n        \"\"\" Returns the list of edges. Convenient when declaring which edges are marked.\n\n        Returns:\n            (list of edge): The list of edges of the underlying graph.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.edges()\n            [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n\n        \"\"\"\n        return deepcopy(self._edges)\n\n    def degree(self, node):\n        \"\"\" Returns the degree of a node.\n\n        Args:\n            node (node): The node you want the degree of.\n\n        Returns:\n            (int): The degree of node.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.degree(0)\n            3\n\n        \"\"\"\n        return len(self._G[node])\n\n    def graph(self):\n        \"\"\" Returns the underlying graph.\n\n        Returns:\n            (networkx.Graph): The underlying graph.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.graph()\n            &lt;networkx.classes.graph.Graph at 0x7bd045d53c70&gt;\n\n        \"\"\"\n        return deepcopy(self._G)\n\n    def virtual_edges(self):\n        \"\"\" Returns a dictionnary that associates its virtual edge to each node.\n\n        Returns:\n            (dict): A dictionnary {node: edge} that associates each node to its virtual edge.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.virtual_edges()\n            {}\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4),starify=True)\n            &gt;&gt;&gt; qw.virtual_edges()\n            {0: (0, '*0'), 1: (1, '*1'), 2: (2, '*2'), 3: (3, '*3')}\n\n        \"\"\"\n        return deepcopy(self._virtual_edges)\n\n\n\n\n\n\n\n    #############################\n    ### Getters/Setters state ###\n    #############################\n\n    def _get_index(self, pos, _type=AddressingType.EDGE):\n        if _type == AddressingType.EDGE:\n            index = self._index[pos]\n            return [2*index, 2*index+1]\n        if _type == AddressingType.VIRTUAL_EDGE:\n            #assert(self._search_nodes and pos in self._virtual_edges.keys())\n            edge = self._virtual_edges[pos]\n            index = self._index[edge]\n            return [2*index, 2*index+1]\n        if _type == AddressingType.NODE:\n            return deepcopy(self._around_nodes_indices[self._nodes_index[pos]])\n        if _type == AddressingType.AMPLITUDE:\n            (u,v) = pos\n            if (u,v) in self._index:\n                edge = (u,v)\n            else:\n                edge = (v,u)\n            index = self._index[edge]\n            return [2*index] if self._polarity[pos]==\"-\" else [2*index+1]\n\n\n\n    def polarity(self, targets):\n        \"\"\" Returns the polarity of the targets.\n\n        Args:   \n            targets (list of target): The list of targets. Targets must be amplitudes.\n\n        Returns:\n            (dict): The polarity (\"+\" or \"-\") of the targets in a dictionnary {target : polarity}.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.polarity([(0,1),(1,0), (2,1),(1,2)])\n            {(0, 1): '-', (1, 0): '+', (2, 1): '+', (1, 2): '-'}\n        \"\"\"\n        indices = {p:self._get_index(p,AddressingType.AMPLITUDE)[0] for p in targets}\n        return {p:\"-\" if indices[p]%2==0 else \"+\" for p in targets}\n\n    def label(self, targets, _type=AddressingType.EDGE):\n        \"\"\" Returns the latex label of the targets.\n\n        Args:   \n            targets (list of target): The list of targets. targets are edges, nodes, virtual edges or amplitudes depending of the addressing type.\n            _type (AddressingType, optional): The addressing type. Decides weither we addresse nodes, edges, amplitudes or virtual edges.\n\n        Returns:\n            (dict): The labels of the targets in a dictionnary {target : labels}.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.label([(0,1),(1,2)], _type = AddressingType.EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n            {(0, 1): ['$\\\\psi_{0,1}^-$', '$\\\\psi_{0,1}^+$'], (1, 2): ['$\\\\psi_{1,2}^-$', '$\\\\psi_{1,2}^+$']}\n            &gt;&gt;&gt; qw.label([(0,1),(1,2)], _type = AddressingType.AMPLITUDE) \n            {(0, 1): ['$\\\\psi_{0,1}^-$'], (1, 2): ['$\\\\psi_{1,2}^-$']}\n            &gt;&gt;&gt; qw.label([0,1], _type = AddressingType.NODE) # 1 node &lt;=&gt; 3 amplitudes\n            {0: ['$\\\\psi_{0,1}^-$', '$\\\\psi_{0,2}^-$', '$\\\\psi_{0,3}^-$'], 1: ['$\\\\psi_{0,1}^+$', '$\\\\psi_{1,2}^-$', '$\\\\psi_{1,3}^-$']}\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), starify=True)\n            &gt;&gt;&gt; qw.label([0,1], _type = AddressingType.VIRTUAL_EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n            {0: ['$\\\\psi_{0,*0}^-$', '$\\\\psi_{0,*0}^+$'], 1: ['$\\\\psi_{1,*1}^-$', '$\\\\psi_{1,*1}^+$']}\n        \"\"\"\n        indices = {p:[i for i in self._get_index(p,_type)] for p in targets}\n        return {p:[self._amplitude_labels[i] for i in indices[p]] for p in targets}\n\n\n    def proba(self, targets, _type=AddressingType.EDGE):\n        \"\"\" Returns the probability to measure one of the targets.\n\n        Args:   \n            targets (list of target): The list of targets. targets are edges, nodes, virtual edges or amplitudes depending of the addressing type.\n            _type (AddressingType, optional): The addressing type. Decides weither we addresse nodes, edges, amplitudes or virtual edges.\n\n        Returns:\n            (dict): The probability of measuring any of the targets as a dictionnary {target : proba}.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.proba([(0,1),(1,2)], _type = AddressingType.EDGE) # 1 edge &lt;=&gt; 2 amplitudes &lt;=&gt; probability of 2/12 with a diagonal distribution\n            {(0, 1): 0.1666666666666667, (1, 2): 0.1666666666666667}\n            &gt;&gt;&gt; qw.proba([(0,1),(1,2)], _type = AddressingType.AMPLITUDE) # 1 amplitude &lt;=&gt; probability of 1/12 with a diagonal distribution\n            {(0, 1): 0.08333333333333336, (1, 2): 0.08333333333333336}\n            &gt;&gt;&gt; qw.proba([0,1], _type = AddressingType.NODE) # 1 node &lt;=&gt; 3 amplitudes &lt;=&gt; probability of 3/12 with a diagonal distribution\n            {0: 0.25000000000000006, 1: 0.25000000000000006}\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), starify=True)\n            &gt;&gt;&gt; qw.proba([0,1], _type = AddressingType.VIRTUAL_EDGE) # 1 edge &lt;=&gt; 2 amplitudes &lt;=&gt; probability of 2/20 with a diagonal distribution on the starified graph\n            {0: 0.09999999999999999, 1: 0.09999999999999999}\n        \"\"\"\n        indices = {p:[i for i in self._get_index(p,_type)] for p in targets}\n        return {p:self._qwf.get_proba(indices[p]) for p in targets}\n\n\n    def state(self, targets, _type=AddressingType.EDGE):\n        \"\"\" Returns the probability to measure one of the targets.\n\n        Args:   \n            targets (list of target): The list of targets. targets are edges, nodes, virtual edges or amplitudes depending of the addressing type.\n            _type (AddressingType, optional): The addressing type. Decides weither we addresse nodes, edges, amplitudes or virtual edges.\n\n        Returns:\n            (dict): The state/amplitude of the targets as a dictionnary {target : state}.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n            &gt;&gt;&gt; qw.state([(0,1),(1,2)], _type = AddressingType.EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n            {(0, 1): array([0.28867513+0.j, 0.28867513+0.j]), (1, 2): array([0.28867513+0.j, 0.28867513+0.j])}\n            &gt;&gt;&gt; qw.state([(0,1),(1,2)], _type = AddressingType.AMPLITUDE)\n            {(0, 1): array([0.28867513+0.j]), (1, 2): array([0.28867513+0.j])}\n            &gt;&gt;&gt; qw.state([0,1], _type = AddressingType.NODE) # 1 node &lt;=&gt; 3 amplitudes\n            {0: array([0.28867513+0.j, 0.28867513+0.j, 0.28867513+0.j]), 1: array([0.28867513+0.j, 0.28867513+0.j, 0.28867513+0.j])}\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), starify=True)\n            &gt;&gt;&gt; qw.state([0,1], _type = AddressingType.VIRTUAL_EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n            {0: array([0.2236068+0.j, 0.2236068+0.j]), 1: array([0.2236068+0.j, 0.2236068+0.j])}\n        \"\"\"\n        indices = {p:[i for i in self._get_index(p,_type)] for p in targets}\n        return {p:np.array([self._qwf.state[i] for i in indices[p]],dtype=complex) for p in targets}\n\n\n\n\n    def set_state(self, new_state):\n        \"\"\" Change the state (i.e. the amplitudes for every edges).\n\n        For an edge (u,v), the amplitudes $\\psi_{u,v}^+$ and $\\psi_{u,v}^-$ will be modified according to the argument.\n        If the new state is not normalized, this method will automatically normalize it.\n\n        Args:\n            new_state (dict): A dictionnary of the form edge: amplitudes. Amplitudes must be numpy arrays or lists of dimension 2.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n            &gt;&gt;&gt; qw.state(qw.edges())\n            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n            &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n            &gt;&gt;&gt; qw.state(qw.edges())\n            {(0, 1): array([0.32444284+0.j        , 0.        +0.16222142j]),\n             (0, 3): array([0.48666426+0.j        , 0.16222142+0.16222142j]),\n             (1, 2): array([0.48666426+0.j        , 0.16222142+0.16222142j]),\n             (2, 3): array([0.48666426+0.j        , 0.16222142+0.16222142j])}\n        \"\"\"\n        s = np.sqrt(sum([abs(new_state[e][0])**2 + abs(new_state[e][1])**2 for e in new_state]))\n        state = np.array([0]*2*self._E,dtype=complex)\n        for i in range(self._E):\n            state[2*i] = new_state[self._edges[i]][0]/s\n            state[2*i+1] = new_state[self._edges[i]][1]/s\n        self._qwf.state = state\n\n    def reset(self):\n        \"\"\" Reset the state to a diagonal one and reset the current step to 0.\n        Do not return anything.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n            &gt;&gt;&gt; qw.state(qw.edges())\n            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n            &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n            &gt;&gt;&gt; qw.state(qw.edges())\n            {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),\n             (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),\n             (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),\n             (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}\n            &gt;&gt;&gt; qw.reset()\n            &gt;&gt;&gt; qw.state(qw.edges())\n            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n\n        \"\"\"\n        self._qwf.reset()\n\n\n\n\n\n\n\n\n    def run(self, pipeline, ticks=1):\n        \"\"\" Run the simulation with the given pipeline for ticks steps.\n        The state will be modified inplace and the proba extracted (if any) will be returned. \n\n        Args:\n            pipeline (PipeLine): The pipeline containing the operations of one step.\n            ticks (int, optional): The number of time steps.\n\n        Returns:\n            (np.array): The probabilities measured in order.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))\n            &gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})\n            &gt;&gt;&gt; qw.proba(qw.edges())\n            {(0, 1): 0.0, (0, 4): 0.0, (1, 2): 1.0, (4, 3): 0.0, (2, 3): 0.0}\n            &gt;&gt;&gt; pipeline = PipeLine()\n            &gt;&gt;&gt; pipeline.add_coin(coins.H)\n            &gt;&gt;&gt; pipeline.add_scattering(\"cycle\")\n            &gt;&gt;&gt; qw.run(pipeline, ticks=2)\n            &gt;&gt;&gt; qw.proba(qw.edges())\n            {(0, 1): 0.0, (0, 4): 0.2499999999999999, (1, 2): 0.4999999999999998, (4, 3): 0.2499999999999999, (2, 3): 0.0}\n            &gt;&gt;&gt; pipeline.add_proba([(0,1)])\n            &gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})\n            &gt;&gt;&gt; p = qw.run(pipeline, ticks=10)\n            &gt;&gt;&gt; p\n            array([0.5, 0., 0.125, 0.0625, 0.25, 0.078125, 0.5078125, 0.265625, 0.29101562, 0.06347656])\n        \"\"\"\n\n        return np.array(self._qwf.run(pipeline._read(self),ticks))\n\n\n    def get_unitary(self, pipeline, dataframe=False, progress=False):\n        \"\"\" For a given pipeline, compute and return the unitary U coresponding to one step of the QW.\n\n        This method **do not** change the state of the QW.\n\n        Args:\n            pipeline (PipeLine): The pipeline containing the operations of one step.\n            dataframe (bool, optional): If True, the result will be a pandas dataframe instead of a numpy array. \n            progress (bool, optional): If True, a tqdm progress bar will be displayed.\n\n        Returns:\n            (numpy array or pandas dataframe): The unitary operator coresponding to one step of the dynamic. If dataframe is set to True, a pandas dataframe will be returned instead.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.balanced_tree(3,1))\n            &gt;&gt;&gt; qw.get_unitary(walk_on_edges(coins.X, \"grover\"))\n            array([[ 0.        +0.j,  1.        +0.j,  0.        +0.j,\n                     0.        +0.j,  0.        +0.j,  0.        +0.j],\n                   [-0.33333333+0.j,  0.        +0.j,  0.66666667+0.j,\n                     0.        +0.j,  0.66666667+0.j,  0.        +0.j],\n                   [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n                     1.        +0.j,  0.        +0.j,  0.        +0.j],\n                   [ 0.66666667+0.j,  0.        +0.j, -0.33333333+0.j,\n                     0.        +0.j,  0.66666667+0.j,  0.        +0.j],\n                   [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n                     0.        +0.j,  0.        +0.j,  1.        +0.j],\n                   [ 0.66666667+0.j,  0.        +0.j,  0.66666667+0.j,\n                     0.        +0.j, -0.33333333+0.j,  0.        +0.j]])\n        \"\"\"\n        old_state = copy.deepcopy(self._qwf.state)\n        U = []\n        for i in (tqdm(range(2*self._E),ncols=100)) if progress else (range(2*self._E)):\n            self._qwf.state = np.array([int(i==j) for j in range(2*self._E)],dtype=complex)\n            self.run(pipeline, ticks=1)\n            U.append(copy.deepcopy(self._qwf.state))\n        self._qwf.state = old_state\n        U = np.array(U,dtype=complex).transpose()\n        if dataframe:\n            df = pd.DataFrame(U, index=self._amplitude_labels, columns=self._amplitude_labels)\n            return df\n        else:\n            return U\n\n    def get_T_P(self, pipeline, waiting=10, maxiter=10000):\n        \"\"\" Computes the hitting time and probability of success for a given QW. \n\n        The waiting parameter is used to accumalate informations about the signal (recommended to be at least 10).\n\n        In details, this algorithm look at the time serie of the probability of success $p(t)$. \n        At any time step $t$, we define $T_{max}(t) = \\\\underset{{t' \\\\leq t}}{\\\\mathrm{argmax }}\\\\; p(t')$ and $T_{min}(t) = \\\\underset{{t' \\\\leq t}}{\\\\mathrm{argmin }} \\\\; p(t')$.\n\n        The algorithms computes the series $p(t)$, $T_{max}(t)$, $T_{min}(t)$ and stop when it encounters `t&gt;waiting` such that $p(t)&lt;\\\\frac{p\\\\left(T_{max}(t)\\\\right)+p\\\\left(T_{max}(t)\\\\right)}{2}$. \n        It then returns $T_{max}(t), p\\\\left(T_{max}(t)\\\\right)$.\n\n        **Warning:** This function won't change the state of the QW.\n\n        If several probability extractions are present in the pipeline, the hitting time returned will be the number of extraction before reaching the first peak.\n\n        Args:\n            pipeline (PipeLine): The pipeline containing the operations of one step.\n            waiting (int, optional): The number of steps the algorithm uses to collect information on the signal. Must be smaller than the hitting time.\n            maxiter (int, optional): The maximum number of iterations of the QW.\n\n        Returns:\n            (int*float): T:int,P:float respectively the hitting time and probability of success.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))\n            &gt;&gt;&gt; qw.get_T_P(search_edges(coins.X, \"grover\", [qw.edges()[0]], -coins.X))\n            (55, 0.9812661464139945)\n        \"\"\"\n\n        old_state = copy.deepcopy(self._qwf.state)\n        ret = self._qwf.carac(pipeline._read(self),waiting,maxiter)\n        self._qwf.state = old_state\n        return ret\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.degree","title":"<code>degree(self, node)</code>","text":"<p>Returns the degree of a node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>node</code> <p>The node you want the degree of.</p> required <p>Returns:</p> Type Description <code>(int)</code> <p>The degree of node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.degree(0)\n3\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def degree(self, node):\n    \"\"\" Returns the degree of a node.\n\n    Args:\n        node (node): The node you want the degree of.\n\n    Returns:\n        (int): The degree of node.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.degree(0)\n        3\n\n    \"\"\"\n    return len(self._G[node])\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.edges","title":"<code>edges(self)</code>","text":"<p>Returns the list of edges. Convenient when declaring which edges are marked.</p> <p>Returns:</p> Type Description <code>(list of edge)</code> <p>The list of edges of the underlying graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.edges()\n[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def edges(self):\n    \"\"\" Returns the list of edges. Convenient when declaring which edges are marked.\n\n    Returns:\n        (list of edge): The list of edges of the underlying graph.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.edges()\n        [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n\n    \"\"\"\n    return deepcopy(self._edges)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.get_T_P","title":"<code>get_T_P(self, pipeline, waiting=10, maxiter=10000)</code>","text":"<p>Computes the hitting time and probability of success for a given QW. </p> <p>The waiting parameter is used to accumalate informations about the signal (recommended to be at least 10).</p> <p>In details, this algorithm look at the time serie of the probability of success \\(p(t)\\).  At any time step \\(t\\), we define \\(T_{max}(t) = \\underset{{t' \\leq t}}{\\mathrm{argmax }}\\; p(t')\\) and \\(T_{min}(t) = \\underset{{t' \\leq t}}{\\mathrm{argmin }} \\; p(t')\\).</p> <p>The algorithms computes the series \\(p(t)\\), \\(T_{max}(t)\\), \\(T_{min}(t)\\) and stop when it encounters <code>t&gt;waiting</code> such that \\(p(t)&lt;\\frac{p\\left(T_{max}(t)\\right)+p\\left(T_{max}(t)\\right)}{2}\\).  It then returns \\(T_{max}(t), p\\left(T_{max}(t)\\right)\\).</p> <p>Warning: This function won't change the state of the QW.</p> <p>If several probability extractions are present in the pipeline, the hitting time returned will be the number of extraction before reaching the first peak.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>PipeLine</code> <p>The pipeline containing the operations of one step.</p> required <code>waiting</code> <code>int</code> <p>The number of steps the algorithm uses to collect information on the signal. Must be smaller than the hitting time.</p> <code>10</code> <code>maxiter</code> <code>int</code> <p>The maximum number of iterations of the QW.</p> <code>10000</code> <p>Returns:</p> Type Description <code>(int*float)</code> <p>T:int,P:float respectively the hitting time and probability of success.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))\n&gt;&gt;&gt; qw.get_T_P(search_edges(coins.X, \"grover\", [qw.edges()[0]], -coins.X))\n(55, 0.9812661464139945)\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def get_T_P(self, pipeline, waiting=10, maxiter=10000):\n    \"\"\" Computes the hitting time and probability of success for a given QW. \n\n    The waiting parameter is used to accumalate informations about the signal (recommended to be at least 10).\n\n    In details, this algorithm look at the time serie of the probability of success $p(t)$. \n    At any time step $t$, we define $T_{max}(t) = \\\\underset{{t' \\\\leq t}}{\\\\mathrm{argmax }}\\\\; p(t')$ and $T_{min}(t) = \\\\underset{{t' \\\\leq t}}{\\\\mathrm{argmin }} \\\\; p(t')$.\n\n    The algorithms computes the series $p(t)$, $T_{max}(t)$, $T_{min}(t)$ and stop when it encounters `t&gt;waiting` such that $p(t)&lt;\\\\frac{p\\\\left(T_{max}(t)\\\\right)+p\\\\left(T_{max}(t)\\\\right)}{2}$. \n    It then returns $T_{max}(t), p\\\\left(T_{max}(t)\\\\right)$.\n\n    **Warning:** This function won't change the state of the QW.\n\n    If several probability extractions are present in the pipeline, the hitting time returned will be the number of extraction before reaching the first peak.\n\n    Args:\n        pipeline (PipeLine): The pipeline containing the operations of one step.\n        waiting (int, optional): The number of steps the algorithm uses to collect information on the signal. Must be smaller than the hitting time.\n        maxiter (int, optional): The maximum number of iterations of the QW.\n\n    Returns:\n        (int*float): T:int,P:float respectively the hitting time and probability of success.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))\n        &gt;&gt;&gt; qw.get_T_P(search_edges(coins.X, \"grover\", [qw.edges()[0]], -coins.X))\n        (55, 0.9812661464139945)\n    \"\"\"\n\n    old_state = copy.deepcopy(self._qwf.state)\n    ret = self._qwf.carac(pipeline._read(self),waiting,maxiter)\n    self._qwf.state = old_state\n    return ret\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.get_unitary","title":"<code>get_unitary(self, pipeline, dataframe=False, progress=False)</code>","text":"<p>For a given pipeline, compute and return the unitary U coresponding to one step of the QW.</p> <p>This method do not change the state of the QW.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>PipeLine</code> <p>The pipeline containing the operations of one step.</p> required <code>dataframe</code> <code>bool</code> <p>If True, the result will be a pandas dataframe instead of a numpy array. </p> <code>False</code> <code>progress</code> <code>bool</code> <p>If True, a tqdm progress bar will be displayed.</p> <code>False</code> <p>Returns:</p> Type Description <code>(numpy array or pandas dataframe)</code> <p>The unitary operator coresponding to one step of the dynamic. If dataframe is set to True, a pandas dataframe will be returned instead.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.balanced_tree(3,1))\n&gt;&gt;&gt; qw.get_unitary(walk_on_edges(coins.X, \"grover\"))\narray([[ 0.        +0.j,  1.        +0.j,  0.        +0.j,\n         0.        +0.j,  0.        +0.j,  0.        +0.j],\n       [-0.33333333+0.j,  0.        +0.j,  0.66666667+0.j,\n         0.        +0.j,  0.66666667+0.j,  0.        +0.j],\n       [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n         1.        +0.j,  0.        +0.j,  0.        +0.j],\n       [ 0.66666667+0.j,  0.        +0.j, -0.33333333+0.j,\n         0.        +0.j,  0.66666667+0.j,  0.        +0.j],\n       [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n         0.        +0.j,  0.        +0.j,  1.        +0.j],\n       [ 0.66666667+0.j,  0.        +0.j,  0.66666667+0.j,\n         0.        +0.j, -0.33333333+0.j,  0.        +0.j]])\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def get_unitary(self, pipeline, dataframe=False, progress=False):\n    \"\"\" For a given pipeline, compute and return the unitary U coresponding to one step of the QW.\n\n    This method **do not** change the state of the QW.\n\n    Args:\n        pipeline (PipeLine): The pipeline containing the operations of one step.\n        dataframe (bool, optional): If True, the result will be a pandas dataframe instead of a numpy array. \n        progress (bool, optional): If True, a tqdm progress bar will be displayed.\n\n    Returns:\n        (numpy array or pandas dataframe): The unitary operator coresponding to one step of the dynamic. If dataframe is set to True, a pandas dataframe will be returned instead.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.balanced_tree(3,1))\n        &gt;&gt;&gt; qw.get_unitary(walk_on_edges(coins.X, \"grover\"))\n        array([[ 0.        +0.j,  1.        +0.j,  0.        +0.j,\n                 0.        +0.j,  0.        +0.j,  0.        +0.j],\n               [-0.33333333+0.j,  0.        +0.j,  0.66666667+0.j,\n                 0.        +0.j,  0.66666667+0.j,  0.        +0.j],\n               [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n                 1.        +0.j,  0.        +0.j,  0.        +0.j],\n               [ 0.66666667+0.j,  0.        +0.j, -0.33333333+0.j,\n                 0.        +0.j,  0.66666667+0.j,  0.        +0.j],\n               [ 0.        +0.j,  0.        +0.j,  0.        +0.j,\n                 0.        +0.j,  0.        +0.j,  1.        +0.j],\n               [ 0.66666667+0.j,  0.        +0.j,  0.66666667+0.j,\n                 0.        +0.j, -0.33333333+0.j,  0.        +0.j]])\n    \"\"\"\n    old_state = copy.deepcopy(self._qwf.state)\n    U = []\n    for i in (tqdm(range(2*self._E),ncols=100)) if progress else (range(2*self._E)):\n        self._qwf.state = np.array([int(i==j) for j in range(2*self._E)],dtype=complex)\n        self.run(pipeline, ticks=1)\n        U.append(copy.deepcopy(self._qwf.state))\n    self._qwf.state = old_state\n    U = np.array(U,dtype=complex).transpose()\n    if dataframe:\n        df = pd.DataFrame(U, index=self._amplitude_labels, columns=self._amplitude_labels)\n        return df\n    else:\n        return U\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.graph","title":"<code>graph(self)</code>","text":"<p>Returns the underlying graph.</p> <p>Returns:</p> Type Description <code>(networkx.Graph)</code> <p>The underlying graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.graph()\n&lt;networkx.classes.graph.Graph at 0x7bd045d53c70&gt;\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def graph(self):\n    \"\"\" Returns the underlying graph.\n\n    Returns:\n        (networkx.Graph): The underlying graph.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.graph()\n        &lt;networkx.classes.graph.Graph at 0x7bd045d53c70&gt;\n\n    \"\"\"\n    return deepcopy(self._G)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.label","title":"<code>label(self, targets, _type=&lt;AddressingType.EDGE: 0&gt;)</code>","text":"<p>Returns the latex label of the targets.</p> <p>!!! args \" \"     targets (list of target): The list of targets. targets are edges, nodes, virtual edges or amplitudes depending of the addressing type.     _type (AddressingType, optional): The addressing type. Decides weither we addresse nodes, edges, amplitudes or virtual edges.</p> <p>Returns:</p> Type Description <code>(dict)</code> <p>The labels of the targets in a dictionnary {target : labels}.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.label([(0,1),(1,2)], _type = AddressingType.EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n{(0, 1): ['$\\psi_{0,1}^-$', '$\\psi_{0,1}^+$'], (1, 2): ['$\\psi_{1,2}^-$', '$\\psi_{1,2}^+$']}\n&gt;&gt;&gt; qw.label([(0,1),(1,2)], _type = AddressingType.AMPLITUDE) \n{(0, 1): ['$\\psi_{0,1}^-$'], (1, 2): ['$\\psi_{1,2}^-$']}\n&gt;&gt;&gt; qw.label([0,1], _type = AddressingType.NODE) # 1 node &lt;=&gt; 3 amplitudes\n{0: ['$\\psi_{0,1}^-$', '$\\psi_{0,2}^-$', '$\\psi_{0,3}^-$'], 1: ['$\\psi_{0,1}^+$', '$\\psi_{1,2}^-$', '$\\psi_{1,3}^-$']}\n&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), starify=True)\n&gt;&gt;&gt; qw.label([0,1], _type = AddressingType.VIRTUAL_EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n{0: ['$\\psi_{0,*0}^-$', '$\\psi_{0,*0}^+$'], 1: ['$\\psi_{1,*1}^-$', '$\\psi_{1,*1}^+$']}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def label(self, targets, _type=AddressingType.EDGE):\n    \"\"\" Returns the latex label of the targets.\n\n    Args:   \n        targets (list of target): The list of targets. targets are edges, nodes, virtual edges or amplitudes depending of the addressing type.\n        _type (AddressingType, optional): The addressing type. Decides weither we addresse nodes, edges, amplitudes or virtual edges.\n\n    Returns:\n        (dict): The labels of the targets in a dictionnary {target : labels}.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.label([(0,1),(1,2)], _type = AddressingType.EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n        {(0, 1): ['$\\\\psi_{0,1}^-$', '$\\\\psi_{0,1}^+$'], (1, 2): ['$\\\\psi_{1,2}^-$', '$\\\\psi_{1,2}^+$']}\n        &gt;&gt;&gt; qw.label([(0,1),(1,2)], _type = AddressingType.AMPLITUDE) \n        {(0, 1): ['$\\\\psi_{0,1}^-$'], (1, 2): ['$\\\\psi_{1,2}^-$']}\n        &gt;&gt;&gt; qw.label([0,1], _type = AddressingType.NODE) # 1 node &lt;=&gt; 3 amplitudes\n        {0: ['$\\\\psi_{0,1}^-$', '$\\\\psi_{0,2}^-$', '$\\\\psi_{0,3}^-$'], 1: ['$\\\\psi_{0,1}^+$', '$\\\\psi_{1,2}^-$', '$\\\\psi_{1,3}^-$']}\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), starify=True)\n        &gt;&gt;&gt; qw.label([0,1], _type = AddressingType.VIRTUAL_EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n        {0: ['$\\\\psi_{0,*0}^-$', '$\\\\psi_{0,*0}^+$'], 1: ['$\\\\psi_{1,*1}^-$', '$\\\\psi_{1,*1}^+$']}\n    \"\"\"\n    indices = {p:[i for i in self._get_index(p,_type)] for p in targets}\n    return {p:[self._amplitude_labels[i] for i in indices[p]] for p in targets}\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.nodes","title":"<code>nodes(self)</code>","text":"<p>Returns the list of nodes. Convenient when declaring which nodes are marked.</p> <p>Returns:</p> Type Description <code>(list of node)</code> <p>The list of nodes of the underlying graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.nodes()\n[0, 1, 2, 3]\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def nodes(self):\n    \"\"\" Returns the list of nodes. Convenient when declaring which nodes are marked.\n\n    Returns:\n        (list of node): The list of nodes of the underlying graph.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.nodes()\n        [0, 1, 2, 3]\n\n    \"\"\"\n    return deepcopy(self._nodes)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.polarity","title":"<code>polarity(self, targets)</code>","text":"<p>Returns the polarity of the targets.</p> <p>!!! args \" \"     targets (list of target): The list of targets. Targets must be amplitudes.</p> <p>Returns:</p> Type Description <code>(dict)</code> <p>The polarity (\"+\" or \"-\") of the targets in a dictionnary {target : polarity}.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.polarity([(0,1),(1,0), (2,1),(1,2)])\n{(0, 1): '-', (1, 0): '+', (2, 1): '+', (1, 2): '-'}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def polarity(self, targets):\n    \"\"\" Returns the polarity of the targets.\n\n    Args:   \n        targets (list of target): The list of targets. Targets must be amplitudes.\n\n    Returns:\n        (dict): The polarity (\"+\" or \"-\") of the targets in a dictionnary {target : polarity}.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.polarity([(0,1),(1,0), (2,1),(1,2)])\n        {(0, 1): '-', (1, 0): '+', (2, 1): '+', (1, 2): '-'}\n    \"\"\"\n    indices = {p:self._get_index(p,AddressingType.AMPLITUDE)[0] for p in targets}\n    return {p:\"-\" if indices[p]%2==0 else \"+\" for p in targets}\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.proba","title":"<code>proba(self, targets, _type=&lt;AddressingType.EDGE: 0&gt;)</code>","text":"<p>Returns the probability to measure one of the targets.</p> <p>!!! args \" \"     targets (list of target): The list of targets. targets are edges, nodes, virtual edges or amplitudes depending of the addressing type.     _type (AddressingType, optional): The addressing type. Decides weither we addresse nodes, edges, amplitudes or virtual edges.</p> <p>Returns:</p> Type Description <code>(dict)</code> <p>The probability of measuring any of the targets as a dictionnary {target : proba}.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.proba([(0,1),(1,2)], _type = AddressingType.EDGE) # 1 edge &lt;=&gt; 2 amplitudes &lt;=&gt; probability of 2/12 with a diagonal distribution\n{(0, 1): 0.1666666666666667, (1, 2): 0.1666666666666667}\n&gt;&gt;&gt; qw.proba([(0,1),(1,2)], _type = AddressingType.AMPLITUDE) # 1 amplitude &lt;=&gt; probability of 1/12 with a diagonal distribution\n{(0, 1): 0.08333333333333336, (1, 2): 0.08333333333333336}\n&gt;&gt;&gt; qw.proba([0,1], _type = AddressingType.NODE) # 1 node &lt;=&gt; 3 amplitudes &lt;=&gt; probability of 3/12 with a diagonal distribution\n{0: 0.25000000000000006, 1: 0.25000000000000006}\n&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), starify=True)\n&gt;&gt;&gt; qw.proba([0,1], _type = AddressingType.VIRTUAL_EDGE) # 1 edge &lt;=&gt; 2 amplitudes &lt;=&gt; probability of 2/20 with a diagonal distribution on the starified graph\n{0: 0.09999999999999999, 1: 0.09999999999999999}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def proba(self, targets, _type=AddressingType.EDGE):\n    \"\"\" Returns the probability to measure one of the targets.\n\n    Args:   \n        targets (list of target): The list of targets. targets are edges, nodes, virtual edges or amplitudes depending of the addressing type.\n        _type (AddressingType, optional): The addressing type. Decides weither we addresse nodes, edges, amplitudes or virtual edges.\n\n    Returns:\n        (dict): The probability of measuring any of the targets as a dictionnary {target : proba}.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.proba([(0,1),(1,2)], _type = AddressingType.EDGE) # 1 edge &lt;=&gt; 2 amplitudes &lt;=&gt; probability of 2/12 with a diagonal distribution\n        {(0, 1): 0.1666666666666667, (1, 2): 0.1666666666666667}\n        &gt;&gt;&gt; qw.proba([(0,1),(1,2)], _type = AddressingType.AMPLITUDE) # 1 amplitude &lt;=&gt; probability of 1/12 with a diagonal distribution\n        {(0, 1): 0.08333333333333336, (1, 2): 0.08333333333333336}\n        &gt;&gt;&gt; qw.proba([0,1], _type = AddressingType.NODE) # 1 node &lt;=&gt; 3 amplitudes &lt;=&gt; probability of 3/12 with a diagonal distribution\n        {0: 0.25000000000000006, 1: 0.25000000000000006}\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), starify=True)\n        &gt;&gt;&gt; qw.proba([0,1], _type = AddressingType.VIRTUAL_EDGE) # 1 edge &lt;=&gt; 2 amplitudes &lt;=&gt; probability of 2/20 with a diagonal distribution on the starified graph\n        {0: 0.09999999999999999, 1: 0.09999999999999999}\n    \"\"\"\n    indices = {p:[i for i in self._get_index(p,_type)] for p in targets}\n    return {p:self._qwf.get_proba(indices[p]) for p in targets}\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.reset","title":"<code>reset(self)</code>","text":"<p>Reset the state to a diagonal one and reset the current step to 0. Do not return anything.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n&gt;&gt;&gt; qw.state(qw.edges())\n{(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n&gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n&gt;&gt;&gt; qw.state(qw.edges())\n{(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),\n (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),\n (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),\n (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}\n&gt;&gt;&gt; qw.reset()\n&gt;&gt;&gt; qw.state(qw.edges())\n{(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def reset(self):\n    \"\"\" Reset the state to a diagonal one and reset the current step to 0.\n    Do not return anything.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n        &gt;&gt;&gt; qw.state(qw.edges())\n        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n        &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n        &gt;&gt;&gt; qw.state(qw.edges())\n        {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),\n         (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),\n         (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),\n         (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}\n        &gt;&gt;&gt; qw.reset()\n        &gt;&gt;&gt; qw.state(qw.edges())\n        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n\n    \"\"\"\n    self._qwf.reset()\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.run","title":"<code>run(self, pipeline, ticks=1)</code>","text":"<p>Run the simulation with the given pipeline for ticks steps. The state will be modified inplace and the proba extracted (if any) will be returned. </p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>PipeLine</code> <p>The pipeline containing the operations of one step.</p> required <code>ticks</code> <code>int</code> <p>The number of time steps.</p> <code>1</code> <p>Returns:</p> Type Description <code>(np.array)</code> <p>The probabilities measured in order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))\n&gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})\n&gt;&gt;&gt; qw.proba(qw.edges())\n{(0, 1): 0.0, (0, 4): 0.0, (1, 2): 1.0, (4, 3): 0.0, (2, 3): 0.0}\n&gt;&gt;&gt; pipeline = PipeLine()\n&gt;&gt;&gt; pipeline.add_coin(coins.H)\n&gt;&gt;&gt; pipeline.add_scattering(\"cycle\")\n&gt;&gt;&gt; qw.run(pipeline, ticks=2)\n&gt;&gt;&gt; qw.proba(qw.edges())\n{(0, 1): 0.0, (0, 4): 0.2499999999999999, (1, 2): 0.4999999999999998, (4, 3): 0.2499999999999999, (2, 3): 0.0}\n&gt;&gt;&gt; pipeline.add_proba([(0,1)])\n&gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})\n&gt;&gt;&gt; p = qw.run(pipeline, ticks=10)\n&gt;&gt;&gt; p\narray([0.5, 0., 0.125, 0.0625, 0.25, 0.078125, 0.5078125, 0.265625, 0.29101562, 0.06347656])\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def run(self, pipeline, ticks=1):\n    \"\"\" Run the simulation with the given pipeline for ticks steps.\n    The state will be modified inplace and the proba extracted (if any) will be returned. \n\n    Args:\n        pipeline (PipeLine): The pipeline containing the operations of one step.\n        ticks (int, optional): The number of time steps.\n\n    Returns:\n        (np.array): The probabilities measured in order.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))\n        &gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})\n        &gt;&gt;&gt; qw.proba(qw.edges())\n        {(0, 1): 0.0, (0, 4): 0.0, (1, 2): 1.0, (4, 3): 0.0, (2, 3): 0.0}\n        &gt;&gt;&gt; pipeline = PipeLine()\n        &gt;&gt;&gt; pipeline.add_coin(coins.H)\n        &gt;&gt;&gt; pipeline.add_scattering(\"cycle\")\n        &gt;&gt;&gt; qw.run(pipeline, ticks=2)\n        &gt;&gt;&gt; qw.proba(qw.edges())\n        {(0, 1): 0.0, (0, 4): 0.2499999999999999, (1, 2): 0.4999999999999998, (4, 3): 0.2499999999999999, (2, 3): 0.0}\n        &gt;&gt;&gt; pipeline.add_proba([(0,1)])\n        &gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})\n        &gt;&gt;&gt; p = qw.run(pipeline, ticks=10)\n        &gt;&gt;&gt; p\n        array([0.5, 0., 0.125, 0.0625, 0.25, 0.078125, 0.5078125, 0.265625, 0.29101562, 0.06347656])\n    \"\"\"\n\n    return np.array(self._qwf.run(pipeline._read(self),ticks))\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.set_state","title":"<code>set_state(self, new_state)</code>","text":"<p>Change the state (i.e. the amplitudes for every edges).</p> <p>For an edge (u,v), the amplitudes \\(\\psi_{u,v}^+\\) and \\(\\psi_{u,v}^-\\) will be modified according to the argument. If the new state is not normalized, this method will automatically normalize it.</p> <p>Parameters:</p> Name Type Description Default <code>new_state</code> <code>dict</code> <p>A dictionnary of the form edge: amplitudes. Amplitudes must be numpy arrays or lists of dimension 2.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n&gt;&gt;&gt; qw.state(qw.edges())\n{(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n&gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n&gt;&gt;&gt; qw.state(qw.edges())\n{(0, 1): array([0.32444284+0.j        , 0.        +0.16222142j]),\n (0, 3): array([0.48666426+0.j        , 0.16222142+0.16222142j]),\n (1, 2): array([0.48666426+0.j        , 0.16222142+0.16222142j]),\n (2, 3): array([0.48666426+0.j        , 0.16222142+0.16222142j])}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def set_state(self, new_state):\n    \"\"\" Change the state (i.e. the amplitudes for every edges).\n\n    For an edge (u,v), the amplitudes $\\psi_{u,v}^+$ and $\\psi_{u,v}^-$ will be modified according to the argument.\n    If the new state is not normalized, this method will automatically normalize it.\n\n    Args:\n        new_state (dict): A dictionnary of the form edge: amplitudes. Amplitudes must be numpy arrays or lists of dimension 2.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))\n        &gt;&gt;&gt; qw.state(qw.edges())\n        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),\n         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),\n         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),\n         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}\n        &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})\n        &gt;&gt;&gt; qw.state(qw.edges())\n        {(0, 1): array([0.32444284+0.j        , 0.        +0.16222142j]),\n         (0, 3): array([0.48666426+0.j        , 0.16222142+0.16222142j]),\n         (1, 2): array([0.48666426+0.j        , 0.16222142+0.16222142j]),\n         (2, 3): array([0.48666426+0.j        , 0.16222142+0.16222142j])}\n    \"\"\"\n    s = np.sqrt(sum([abs(new_state[e][0])**2 + abs(new_state[e][1])**2 for e in new_state]))\n    state = np.array([0]*2*self._E,dtype=complex)\n    for i in range(self._E):\n        state[2*i] = new_state[self._edges[i]][0]/s\n        state[2*i+1] = new_state[self._edges[i]][1]/s\n    self._qwf.state = state\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.state","title":"<code>state(self, targets, _type=&lt;AddressingType.EDGE: 0&gt;)</code>","text":"<p>Returns the probability to measure one of the targets.</p> <p>!!! args \" \"     targets (list of target): The list of targets. targets are edges, nodes, virtual edges or amplitudes depending of the addressing type.     _type (AddressingType, optional): The addressing type. Decides weither we addresse nodes, edges, amplitudes or virtual edges.</p> <p>Returns:</p> Type Description <code>(dict)</code> <p>The state/amplitude of the targets as a dictionnary {target : state}.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.state([(0,1),(1,2)], _type = AddressingType.EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n{(0, 1): array([0.28867513+0.j, 0.28867513+0.j]), (1, 2): array([0.28867513+0.j, 0.28867513+0.j])}\n&gt;&gt;&gt; qw.state([(0,1),(1,2)], _type = AddressingType.AMPLITUDE)\n{(0, 1): array([0.28867513+0.j]), (1, 2): array([0.28867513+0.j])}\n&gt;&gt;&gt; qw.state([0,1], _type = AddressingType.NODE) # 1 node &lt;=&gt; 3 amplitudes\n{0: array([0.28867513+0.j, 0.28867513+0.j, 0.28867513+0.j]), 1: array([0.28867513+0.j, 0.28867513+0.j, 0.28867513+0.j])}\n&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), starify=True)\n&gt;&gt;&gt; qw.state([0,1], _type = AddressingType.VIRTUAL_EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n{0: array([0.2236068+0.j, 0.2236068+0.j]), 1: array([0.2236068+0.j, 0.2236068+0.j])}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def state(self, targets, _type=AddressingType.EDGE):\n    \"\"\" Returns the probability to measure one of the targets.\n\n    Args:   \n        targets (list of target): The list of targets. targets are edges, nodes, virtual edges or amplitudes depending of the addressing type.\n        _type (AddressingType, optional): The addressing type. Decides weither we addresse nodes, edges, amplitudes or virtual edges.\n\n    Returns:\n        (dict): The state/amplitude of the targets as a dictionnary {target : state}.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.state([(0,1),(1,2)], _type = AddressingType.EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n        {(0, 1): array([0.28867513+0.j, 0.28867513+0.j]), (1, 2): array([0.28867513+0.j, 0.28867513+0.j])}\n        &gt;&gt;&gt; qw.state([(0,1),(1,2)], _type = AddressingType.AMPLITUDE)\n        {(0, 1): array([0.28867513+0.j]), (1, 2): array([0.28867513+0.j])}\n        &gt;&gt;&gt; qw.state([0,1], _type = AddressingType.NODE) # 1 node &lt;=&gt; 3 amplitudes\n        {0: array([0.28867513+0.j, 0.28867513+0.j, 0.28867513+0.j]), 1: array([0.28867513+0.j, 0.28867513+0.j, 0.28867513+0.j])}\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), starify=True)\n        &gt;&gt;&gt; qw.state([0,1], _type = AddressingType.VIRTUAL_EDGE) # 1 edge &lt;=&gt; 2 amplitudes\n        {0: array([0.2236068+0.j, 0.2236068+0.j]), 1: array([0.2236068+0.j, 0.2236068+0.j])}\n    \"\"\"\n    indices = {p:[i for i in self._get_index(p,_type)] for p in targets}\n    return {p:np.array([self._qwf.state[i] for i in indices[p]],dtype=complex) for p in targets}\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.QWSearch.virtual_edges","title":"<code>virtual_edges(self)</code>","text":"<p>Returns a dictionnary that associates its virtual edge to each node.</p> <p>Returns:</p> Type Description <code>(dict)</code> <p>A dictionnary {node: edge} that associates each node to its virtual edge.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n&gt;&gt;&gt; qw.virtual_edges()\n{}\n&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4),starify=True)\n&gt;&gt;&gt; qw.virtual_edges()\n{0: (0, '*0'), 1: (1, '*1'), 2: (2, '*2'), 3: (3, '*3')}\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def virtual_edges(self):\n    \"\"\" Returns a dictionnary that associates its virtual edge to each node.\n\n    Returns:\n        (dict): A dictionnary {node: edge} that associates each node to its virtual edge.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))\n        &gt;&gt;&gt; qw.virtual_edges()\n        {}\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4),starify=True)\n        &gt;&gt;&gt; qw.virtual_edges()\n        {0: (0, '*0'), 1: (1, '*1'), 2: (2, '*2'), 3: (3, '*3')}\n\n    \"\"\"\n    return deepcopy(self._virtual_edges)\n</code></pre>"},{"location":"qwsearch/#pipeline","title":"PipeLine","text":""},{"location":"qwsearch/#qwgraph.qwsearch.PipeLine","title":"<code> PipeLine            (list)         </code>","text":"<p>Pipeline class for QWSearch This class is used to give instruction to the QWSearch. It inherits from list and is basically a list of instructions to the walk. Instructions are executed by the walk in order. There are four types of instruction:     - Instruction.SCATTERING : An operation around the nodes.     - Instruction.COIN : An operation on the edges.     - Instruction.UNITARY : An operation on arbitrary amplitudes.     - Instruction.PROBA : An instruction to extract the proba of being at some positions. Addition between pipelines and multiplication by an integer are implemented.</p> <p>Attributes:</p> Name Type Description <code>addressing_type</code> <code>AddressingType</code> <p>The default way to address amplitudes.</p> <p>Parameters:</p> Name Type Description Default <code>addressing_type</code> <code>AddressingType</code> <p>The default way to address amplitudes.</p> <code>&lt;AddressingType.EDGE: 0&gt;</code> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>class PipeLine(list): \n    \"\"\" Pipeline class for QWSearch\n    This class is used to give instruction to the QWSearch. It inherits from list and is basically a list of instructions to the walk.\n    Instructions are executed by the walk in order.\n    There are four types of instruction:\n        - Instruction.SCATTERING : An operation around the nodes.\n        - Instruction.COIN : An operation on the edges.\n        - Instruction.UNITARY : An operation on arbitrary amplitudes.\n        - Instruction.PROBA : An instruction to extract the proba of being at some positions.\n    Addition between pipelines and multiplication by an integer are implemented.\n\n    Attributes:\n        addressing_type (AddressingType): The default way to address amplitudes.\n\n    Args:\n        addressing_type (AddressingType, optional): The default way to address amplitudes.\n    \"\"\"\n    def __init__(self, addressing_type=AddressingType.EDGE):\n        super().__init__([])\n        self.addressing_type=addressing_type\n    def __repr__(self):\n        l = [str(dic[\"instruction\"].name) if \"name\" not in dic or dic[\"name\"] == None else \"{}({})\".format(dic[\"instruction\"].name,dic[\"name\"]) for dic in self]\n        return \" -&gt; \".join(l)\n\n    def __add__(self, other):\n        p = PipeLine(addressing_type=self.addressing_type)\n        p.extend(self)\n        p.extend(other)\n        return p\n    def __mul__(self,other):\n        p = PipeLine(addressing_type=self.addressing_type)\n        p.extend(list(self)*other)\n        return p\n\n    def _read_entry(self, dic, qw):\n        op = qwfast.OperationWrapper()\n        if dic[\"instruction\"] == Instruction.COIN:\n            Coin = qwfast.Coin()\n            if type(dic[\"coin\"]) == type(dict()): # Dictionnary\n                Coin.set_micro([dic[\"coin\"][e] for e in qw._edges])\n            elif len(np.shape(dic[\"coin\"])) == 2: # One matrix\n                Coin.set_macro(dic[\"coin\"])\n            else:\n                raise \"Wrong type or dimension for the coin\"\n            op.set_to_coin(Coin)\n            return op\n\n        if dic[\"instruction\"] == Instruction.PROBA:\n            pos = list(chain.from_iterable([qw._get_index(i, dic[\"addressing_type\"]) for i in dic[\"targets\"]]))\n            op.set_to_proba(pos)\n            return op\n\n        if dic[\"instruction\"] == Instruction.UNITARY:\n            pos = list(chain.from_iterable([qw._get_index(i, dic[\"addressing_type\"]) for i in dic[\"targets\"]]))\n            U = dic[\"unitary\"]\n            if type(U) == type(lambda x:x):\n                U = U(len(pos))\n            Unitary = qwfast.UnitaryOp(pos, U)\n            op.set_to_unitary(Unitary)\n            return op\n\n\n        if dic[\"instruction\"] == Instruction.SCATTERING:\n            Scatter = qwfast.Scattering()\n            if dic[\"mode\"]==\"global\":\n                if dic[\"scattering\"] == \"cycle\":\n                    Scatter.set_type(0, [])\n                elif dic[\"scattering\"] == \"grover\":\n                    Scatter.set_type(1, [])\n                else:\n                    raise \"Scattering not recognized\"\n            elif dic[\"mode\"]==\"node\":\n                data = [[] for i in qw._nodes]\n                for i in range(len(qw._nodes)):\n                    data[i] = dic[\"scattering\"][qw._nodes[i]]\n\n                Scatter.set_type(3, data)\n\n            elif dic[\"mode\"]==\"degree\":\n                data = [[] for i in range(max(qw._degrees)+1)]\n                for i in qw._degrees:\n                    data[i] = dic[\"scattering\"](i)\n\n                Scatter.set_type(2, data)\n\n            else:\n                raise \"Wrong argument for the scattering\"\n            op.set_to_scattering(Scatter)\n            return op\n\n\n    def _read(self, qw):\n        return [self._read_entry(dic,qw) for dic in self]\n\n    def add_unitary(self, targets, unitary, addressing_type=None, name=None):\n        \"\"\" Add an arbitrary unitary application to the pipeline.\n        Args:\n            targets (list): The list of targets.\n            unitary (np.array): The matrix of the unitary operator. Alternatively, can be a function that takes one argument (the degree) and returns an unitary.\n            addressing_type (AddressingType, optional): The way the targets are addressed (edges, nodes, virtual edges or amplitudes). If set to None, this parameter will take the value of the class attribute addressing_type.\n            name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n        Examples:\n            &gt;&gt;&gt; pipeline = PipeLine()\n            &gt;&gt;&gt; pipeline.add_unitary([(0,1)], -np.eye(2), addressing_type=AddressingType.EDGE, name=\"oracle on an edge\")\n            &gt;&gt;&gt; pipeline.add_unitary([0], -np.eye(2), addressing_type=AddressingType.NODE, name=\"oracle around a node\")\n            &gt;&gt;&gt; print(pipeline)\n            UNITARY(oracle on an edge) -&gt; UNITARY(oracle around a node)\n        \"\"\"\n        dic = {\"instruction\":Instruction.UNITARY, \"targets\":targets, \"unitary\":unitary, \"addressing_type\":addressing_type}\n        if name != None:\n            dic[\"name\"] = str(name)\n        if addressing_type == None:\n            dic[\"addressing_type\"] = self.addressing_type\n        self.append(dic)\n\n    def add_proba(self, targets, addressing_type=None, name=None):\n        \"\"\" Add an extraction of the probability of being on one of the targets.\n        Args:\n            targets (list): The list of targets.\n            addressing_type (AddressingType, optional): The way the target is addressed (edges, nodes, virtual edges or amplitudes). If set to None, this parameter will take the value of the class attribute addressing_type.\n            name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n        Examples:\n            &gt;&gt;&gt; pipeline = PipeLine()\n            &gt;&gt;&gt; pipeline.add_proba([(0,1)], addressing_type=AddressingType.EDGE, name=\"proba on an edge\")\n            &gt;&gt;&gt; pipeline.add_proba([0], addressing_type=AddressingType.NODE, name=\"proba around a node\")\n            &gt;&gt;&gt; print(pipeline)\n            PROBA(proba on an edge) -&gt; PROBA(proba around a node)\n        \"\"\"\n        dic = {\"instruction\":Instruction.PROBA, \"targets\":targets, \"addressing_type\":addressing_type}\n        if name != None:\n            dic[\"name\"] = str(name)\n        if addressing_type == None:\n            dic[\"addressing_type\"] = self.addressing_type\n        self.append(dic)\n\n    def add_coin(self, coin, name=None):\n        \"\"\" Add a coin operation to the pipeline.\n        Coin operations are operations on the edges.\n        Args:\n            coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.\n            name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), True)\n            &gt;&gt;&gt; pipeline = PipeLine()\n            &gt;&gt;&gt; pipeline.add_coin(np.eye(2), name=\"identity coin\")\n            &gt;&gt;&gt; pipeline.add_coin({e : np.eye(2) * np.exp(1j * np.random.random()) for e in qw.edges()}, name=\"coin different for each edge\")\n            &gt;&gt;&gt; print(pipeline)\n            COIN(identity coin) -&gt; COIN(coin different for each edge)\n        \"\"\"\n        dic = {\"instruction\":Instruction.COIN, \"coin\":coin}\n        if name != None:\n            dic[\"name\"] = str(name)\n        self.append(dic)\n\n    def add_scattering(self, scattering, name=None):\n        \"\"\" Add a scattering operation to the pipeline.\n        Scattering operations are operations around the nodes.\n        Args:\n            scattering (str): \"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.\n            name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n        Examples:\n            &gt;&gt;&gt; pipeline = PipeLine()\n            &gt;&gt;&gt; pipeline.add_scattering(\"grover\", name=\"Grover diffusion\")\n            &gt;&gt;&gt; pipeline.add_scattering(\"cycle\", name=\"cycle\")\n            &gt;&gt;&gt; print(pipeline)\n            SCATTERING(Grover diffusion) -&gt; SCATTERING(cycle)\n        \"\"\"\n        dic = {\"instruction\":Instruction.SCATTERING, \"scattering\":scattering, \"mode\":\"global\"}\n        if name != None:\n            dic[\"name\"] = str(name)\n        self.append(dic)\n\n    def add_scattering_by_node(self, scattering, name=None):\n        \"\"\" Add a different scattering operation for each node to the pipeline.\n        Scattering operations are operations around the nodes.\n        Args:\n            scattering (dict): A dictionnary {node : unitary} associating to each node its scattering operator.\n            name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.balanced_tree(3,1), True)\n            &gt;&gt;&gt; grover = lambda d: (2/d)*np.ones((d,d)) - np.eye(d)\n            &gt;&gt;&gt; pipeline = PipeLine()\n            &gt;&gt;&gt; pipeline.add_scattering_by_node({u : grover(qw.degree(u)) for u in qw.nodes()}, name=\"personalised scattering\") # Grover on everyone\n            &gt;&gt;&gt; print(pipeline)\n            SCATTERING(personalised scattering)\n        \"\"\"\n        dic = {\"instruction\":Instruction.SCATTERING, \"scattering\":scattering, \"mode\":\"node\"}\n        if name != None:\n            dic[\"name\"] = str(name)\n        self.append(dic)\n\n    def add_scattering_by_degree(self, scattering, name=None):\n        \"\"\" Add a different scattering operation for each degree to the pipeline.\n        Scattering operations are operations around the nodes.\n        Args:\n            scattering (function): A function associating for each possible degree the coresponding scattering operator.\n            name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n        Examples:\n            &gt;&gt;&gt; qw = QWSearch(nx.balanced_tree(3,1), True)\n            &gt;&gt;&gt; grover = lambda d: (2/d)*np.ones((d,d)) - np.eye(d)\n            &gt;&gt;&gt; pipeline = PipeLine()\n            &gt;&gt;&gt; pipeline.add_scattering_by_degree(grover, name=\"personalised scattering\") # Grover on everyone\n            &gt;&gt;&gt; print(pipeline)\n            SCATTERING(personalised scattering)\n        \"\"\"\n        dic = {\"instruction\":Instruction.SCATTERING, \"scattering\":scattering, \"mode\":\"degree\"}\n        if name != None:\n            dic[\"name\"] = str(name)\n        self.append(dic)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.PipeLine.add_coin","title":"<code>add_coin(self, coin, name=None)</code>","text":"<p>Add a coin operation to the pipeline. Coin operations are operations on the edges.</p> <p>Parameters:</p> Name Type Description Default <code>coin</code> <code>np.array or dict</code> <p>The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.</p> required <code>name</code> <code>str</code> <p>A name of the operation. As no effect on the dynamic but shows when printing the pipeline.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), True)\n&gt;&gt;&gt; pipeline = PipeLine()\n&gt;&gt;&gt; pipeline.add_coin(np.eye(2), name=\"identity coin\")\n&gt;&gt;&gt; pipeline.add_coin({e : np.eye(2) * np.exp(1j * np.random.random()) for e in qw.edges()}, name=\"coin different for each edge\")\n&gt;&gt;&gt; print(pipeline)\nCOIN(identity coin) -&gt; COIN(coin different for each edge)\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def add_coin(self, coin, name=None):\n    \"\"\" Add a coin operation to the pipeline.\n    Coin operations are operations on the edges.\n    Args:\n        coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.\n        name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4), True)\n        &gt;&gt;&gt; pipeline = PipeLine()\n        &gt;&gt;&gt; pipeline.add_coin(np.eye(2), name=\"identity coin\")\n        &gt;&gt;&gt; pipeline.add_coin({e : np.eye(2) * np.exp(1j * np.random.random()) for e in qw.edges()}, name=\"coin different for each edge\")\n        &gt;&gt;&gt; print(pipeline)\n        COIN(identity coin) -&gt; COIN(coin different for each edge)\n    \"\"\"\n    dic = {\"instruction\":Instruction.COIN, \"coin\":coin}\n    if name != None:\n        dic[\"name\"] = str(name)\n    self.append(dic)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.PipeLine.add_proba","title":"<code>add_proba(self, targets, addressing_type=None, name=None)</code>","text":"<p>Add an extraction of the probability of being on one of the targets.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>list</code> <p>The list of targets.</p> required <code>addressing_type</code> <code>AddressingType</code> <p>The way the target is addressed (edges, nodes, virtual edges or amplitudes). If set to None, this parameter will take the value of the class attribute addressing_type.</p> <code>None</code> <code>name</code> <code>str</code> <p>A name of the operation. As no effect on the dynamic but shows when printing the pipeline.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pipeline = PipeLine()\n&gt;&gt;&gt; pipeline.add_proba([(0,1)], addressing_type=AddressingType.EDGE, name=\"proba on an edge\")\n&gt;&gt;&gt; pipeline.add_proba([0], addressing_type=AddressingType.NODE, name=\"proba around a node\")\n&gt;&gt;&gt; print(pipeline)\nPROBA(proba on an edge) -&gt; PROBA(proba around a node)\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def add_proba(self, targets, addressing_type=None, name=None):\n    \"\"\" Add an extraction of the probability of being on one of the targets.\n    Args:\n        targets (list): The list of targets.\n        addressing_type (AddressingType, optional): The way the target is addressed (edges, nodes, virtual edges or amplitudes). If set to None, this parameter will take the value of the class attribute addressing_type.\n        name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n    Examples:\n        &gt;&gt;&gt; pipeline = PipeLine()\n        &gt;&gt;&gt; pipeline.add_proba([(0,1)], addressing_type=AddressingType.EDGE, name=\"proba on an edge\")\n        &gt;&gt;&gt; pipeline.add_proba([0], addressing_type=AddressingType.NODE, name=\"proba around a node\")\n        &gt;&gt;&gt; print(pipeline)\n        PROBA(proba on an edge) -&gt; PROBA(proba around a node)\n    \"\"\"\n    dic = {\"instruction\":Instruction.PROBA, \"targets\":targets, \"addressing_type\":addressing_type}\n    if name != None:\n        dic[\"name\"] = str(name)\n    if addressing_type == None:\n        dic[\"addressing_type\"] = self.addressing_type\n    self.append(dic)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.PipeLine.add_scattering","title":"<code>add_scattering(self, scattering, name=None)</code>","text":"<p>Add a scattering operation to the pipeline. Scattering operations are operations around the nodes.</p> <p>Parameters:</p> Name Type Description Default <code>scattering</code> <code>str</code> <p>\"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.</p> required <code>name</code> <code>str</code> <p>A name of the operation. As no effect on the dynamic but shows when printing the pipeline.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pipeline = PipeLine()\n&gt;&gt;&gt; pipeline.add_scattering(\"grover\", name=\"Grover diffusion\")\n&gt;&gt;&gt; pipeline.add_scattering(\"cycle\", name=\"cycle\")\n&gt;&gt;&gt; print(pipeline)\nSCATTERING(Grover diffusion) -&gt; SCATTERING(cycle)\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def add_scattering(self, scattering, name=None):\n    \"\"\" Add a scattering operation to the pipeline.\n    Scattering operations are operations around the nodes.\n    Args:\n        scattering (str): \"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.\n        name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n    Examples:\n        &gt;&gt;&gt; pipeline = PipeLine()\n        &gt;&gt;&gt; pipeline.add_scattering(\"grover\", name=\"Grover diffusion\")\n        &gt;&gt;&gt; pipeline.add_scattering(\"cycle\", name=\"cycle\")\n        &gt;&gt;&gt; print(pipeline)\n        SCATTERING(Grover diffusion) -&gt; SCATTERING(cycle)\n    \"\"\"\n    dic = {\"instruction\":Instruction.SCATTERING, \"scattering\":scattering, \"mode\":\"global\"}\n    if name != None:\n        dic[\"name\"] = str(name)\n    self.append(dic)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.PipeLine.add_scattering_by_degree","title":"<code>add_scattering_by_degree(self, scattering, name=None)</code>","text":"<p>Add a different scattering operation for each degree to the pipeline. Scattering operations are operations around the nodes.</p> <p>Parameters:</p> Name Type Description Default <code>scattering</code> <code>function</code> <p>A function associating for each possible degree the coresponding scattering operator.</p> required <code>name</code> <code>str</code> <p>A name of the operation. As no effect on the dynamic but shows when printing the pipeline.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.balanced_tree(3,1), True)\n&gt;&gt;&gt; grover = lambda d: (2/d)*np.ones((d,d)) - np.eye(d)\n&gt;&gt;&gt; pipeline = PipeLine()\n&gt;&gt;&gt; pipeline.add_scattering_by_degree(grover, name=\"personalised scattering\") # Grover on everyone\n&gt;&gt;&gt; print(pipeline)\nSCATTERING(personalised scattering)\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def add_scattering_by_degree(self, scattering, name=None):\n    \"\"\" Add a different scattering operation for each degree to the pipeline.\n    Scattering operations are operations around the nodes.\n    Args:\n        scattering (function): A function associating for each possible degree the coresponding scattering operator.\n        name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.balanced_tree(3,1), True)\n        &gt;&gt;&gt; grover = lambda d: (2/d)*np.ones((d,d)) - np.eye(d)\n        &gt;&gt;&gt; pipeline = PipeLine()\n        &gt;&gt;&gt; pipeline.add_scattering_by_degree(grover, name=\"personalised scattering\") # Grover on everyone\n        &gt;&gt;&gt; print(pipeline)\n        SCATTERING(personalised scattering)\n    \"\"\"\n    dic = {\"instruction\":Instruction.SCATTERING, \"scattering\":scattering, \"mode\":\"degree\"}\n    if name != None:\n        dic[\"name\"] = str(name)\n    self.append(dic)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.PipeLine.add_scattering_by_node","title":"<code>add_scattering_by_node(self, scattering, name=None)</code>","text":"<p>Add a different scattering operation for each node to the pipeline. Scattering operations are operations around the nodes.</p> <p>Parameters:</p> Name Type Description Default <code>scattering</code> <code>dict</code> <p>A dictionnary {node : unitary} associating to each node its scattering operator.</p> required <code>name</code> <code>str</code> <p>A name of the operation. As no effect on the dynamic but shows when printing the pipeline.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.balanced_tree(3,1), True)\n&gt;&gt;&gt; grover = lambda d: (2/d)*np.ones((d,d)) - np.eye(d)\n&gt;&gt;&gt; pipeline = PipeLine()\n&gt;&gt;&gt; pipeline.add_scattering_by_node({u : grover(qw.degree(u)) for u in qw.nodes()}, name=\"personalised scattering\") # Grover on everyone\n&gt;&gt;&gt; print(pipeline)\nSCATTERING(personalised scattering)\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def add_scattering_by_node(self, scattering, name=None):\n    \"\"\" Add a different scattering operation for each node to the pipeline.\n    Scattering operations are operations around the nodes.\n    Args:\n        scattering (dict): A dictionnary {node : unitary} associating to each node its scattering operator.\n        name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.balanced_tree(3,1), True)\n        &gt;&gt;&gt; grover = lambda d: (2/d)*np.ones((d,d)) - np.eye(d)\n        &gt;&gt;&gt; pipeline = PipeLine()\n        &gt;&gt;&gt; pipeline.add_scattering_by_node({u : grover(qw.degree(u)) for u in qw.nodes()}, name=\"personalised scattering\") # Grover on everyone\n        &gt;&gt;&gt; print(pipeline)\n        SCATTERING(personalised scattering)\n    \"\"\"\n    dic = {\"instruction\":Instruction.SCATTERING, \"scattering\":scattering, \"mode\":\"node\"}\n    if name != None:\n        dic[\"name\"] = str(name)\n    self.append(dic)\n</code></pre>"},{"location":"qwsearch/#qwgraph.qwsearch.PipeLine.add_unitary","title":"<code>add_unitary(self, targets, unitary, addressing_type=None, name=None)</code>","text":"<p>Add an arbitrary unitary application to the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>list</code> <p>The list of targets.</p> required <code>unitary</code> <code>np.array</code> <p>The matrix of the unitary operator. Alternatively, can be a function that takes one argument (the degree) and returns an unitary.</p> required <code>addressing_type</code> <code>AddressingType</code> <p>The way the targets are addressed (edges, nodes, virtual edges or amplitudes). If set to None, this parameter will take the value of the class attribute addressing_type.</p> <code>None</code> <code>name</code> <code>str</code> <p>A name of the operation. As no effect on the dynamic but shows when printing the pipeline.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pipeline = PipeLine()\n&gt;&gt;&gt; pipeline.add_unitary([(0,1)], -np.eye(2), addressing_type=AddressingType.EDGE, name=\"oracle on an edge\")\n&gt;&gt;&gt; pipeline.add_unitary([0], -np.eye(2), addressing_type=AddressingType.NODE, name=\"oracle around a node\")\n&gt;&gt;&gt; print(pipeline)\nUNITARY(oracle on an edge) -&gt; UNITARY(oracle around a node)\n</code></pre> Source code in <code>qwgraph/qwsearch.py</code> <pre><code>def add_unitary(self, targets, unitary, addressing_type=None, name=None):\n    \"\"\" Add an arbitrary unitary application to the pipeline.\n    Args:\n        targets (list): The list of targets.\n        unitary (np.array): The matrix of the unitary operator. Alternatively, can be a function that takes one argument (the degree) and returns an unitary.\n        addressing_type (AddressingType, optional): The way the targets are addressed (edges, nodes, virtual edges or amplitudes). If set to None, this parameter will take the value of the class attribute addressing_type.\n        name (str, optional): A name of the operation. As no effect on the dynamic but shows when printing the pipeline.\n\n    Examples:\n        &gt;&gt;&gt; pipeline = PipeLine()\n        &gt;&gt;&gt; pipeline.add_unitary([(0,1)], -np.eye(2), addressing_type=AddressingType.EDGE, name=\"oracle on an edge\")\n        &gt;&gt;&gt; pipeline.add_unitary([0], -np.eye(2), addressing_type=AddressingType.NODE, name=\"oracle around a node\")\n        &gt;&gt;&gt; print(pipeline)\n        UNITARY(oracle on an edge) -&gt; UNITARY(oracle around a node)\n    \"\"\"\n    dic = {\"instruction\":Instruction.UNITARY, \"targets\":targets, \"unitary\":unitary, \"addressing_type\":addressing_type}\n    if name != None:\n        dic[\"name\"] = str(name)\n    if addressing_type == None:\n        dic[\"addressing_type\"] = self.addressing_type\n    self.append(dic)\n</code></pre>"},{"location":"qwsearch/#default-pipelines","title":"Default Pipelines","text":""},{"location":"qwsearch/#qwgraph.pipelines.search_edges","title":"<code>search_edges(coin, scattering, marked, oracle=None)</code>","text":"<p>Create a default pipeline of a QW on edges searching edges</p> <p>Parameters:</p> Name Type Description Default <code>coin</code> <code>numpy array</code> <p>coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.</p> required <code>scattering</code> <code>str</code> <p>\"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.</p> required <code>marked</code> <code>list</code> <p>the list of marked edges.</p> required <code>oracle</code> <code>numpy array</code> <p>The two by two unitary operator of the oracle. If None, then -X will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>(PipeLine)</code> <p>The pipeline of a QW on edges searching edges.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100), starify=True)\n&gt;&gt;&gt; search_edges(coins.X, \"grover\", qw.edges()[0:4], -coins.X)\nUNITARY(Oracle on (0, 1)) -&gt; UNITARY(Oracle on (0, 2)) -&gt; UNITARY(Oracle on (0, 3)) -&gt; UNITARY(Oracle on (0, 4)) -&gt; COIN -&gt; SCATTERING -&gt; PROBA\n</code></pre> Source code in <code>qwgraph/pipelines.py</code> <pre><code>def search_edges(coin, scattering, marked, oracle=None):\n    \"\"\" Create a default pipeline of a QW on edges searching edges\n\n    Args:\n        coin (numpy array): coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.\n        scattering (str): \"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.\n        marked (list): the list of marked edges.\n        oracle (numpy array, optional): The two by two unitary operator of the oracle. If None, then -X will be used.\n\n    Returns:\n        (PipeLine): The pipeline of a QW on edges searching edges.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100), starify=True)\n        &gt;&gt;&gt; search_edges(coins.X, \"grover\", qw.edges()[0:4], -coins.X)\n        UNITARY(Oracle on (0, 1)) -&gt; UNITARY(Oracle on (0, 2)) -&gt; UNITARY(Oracle on (0, 3)) -&gt; UNITARY(Oracle on (0, 4)) -&gt; COIN -&gt; SCATTERING -&gt; PROBA\n\n    \"\"\"\n    pipeline = qws.PipeLine(addressing_type=qws.AddressingType.EDGE)\n    if type(oracle) == type(None):\n        oracle = -_X\n    for m in marked:\n        pipeline.add_unitary([m], oracle, name=f\"Oracle on {m}\")\n    pipeline = pipeline + walk_on_edges(coin, scattering)\n    pipeline.add_proba(marked)\n    return pipeline\n</code></pre>"},{"location":"qwsearch/#qwgraph.pipelines.search_nodes","title":"<code>search_nodes(scattering, marked, oracle=&lt;function &lt;lambda&gt; at 0x73c303abe4d0&gt;, coin=array([[0.+0.j, 1.+0.j],[1.+0.j, 0.+0.j]]))</code>","text":"<p>Create a default pipeline of a QW on nodes searching nodes</p> <p>Parameters:</p> Name Type Description Default <code>scattering</code> <code>str</code> <p>\"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.</p> required <code>marked</code> <code>list</code> <p>the list of marked edges.</p> required <code>oracle</code> <code>numpy array</code> <p>The unitary operator of the oracle (or a function of the degree returning the unitary). If None, then -I will be used.</p> <code>&lt;function &lt;lambda&gt; at 0x73c303abe4d0&gt;</code> <code>coin</code> <code>numpy array</code> <p>coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.</p> <code>array([[0.+0.j, 1.+0.j],        [1.+0.j, 0.+0.j]])</code> <p>Returns:</p> Type Description <code>(PipeLine)</code> <p>The pipeline of a QW on edges searching edges.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100), starify=True)\n&gt;&gt;&gt; search_nodes(\"grover\", qw.nodes()[0:4], lambda d:-np.eye(d), coins.X)\nUNITARY(Oracle on 0) -&gt; UNITARY(Oracle on 1) -&gt; UNITARY(Oracle on 2) -&gt; UNITARY(Oracle on 3) -&gt; SCATTERING -&gt; COIN -&gt; PROBA\n</code></pre> Source code in <code>qwgraph/pipelines.py</code> <pre><code>def search_nodes(scattering, marked, oracle=lambda d:-np.eye(d), coin=_X):\n    \"\"\" Create a default pipeline of a QW on nodes searching nodes\n\n    Args:\n        scattering (str): \"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.\n        marked (list): the list of marked edges.\n        oracle (numpy array, optional): The unitary operator of the oracle (or a function of the degree returning the unitary). If None, then -I will be used.\n        coin (numpy array, optional): coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.\n\n    Returns:\n        (PipeLine): The pipeline of a QW on edges searching edges.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100), starify=True)\n        &gt;&gt;&gt; search_nodes(\"grover\", qw.nodes()[0:4], lambda d:-np.eye(d), coins.X)\n        UNITARY(Oracle on 0) -&gt; UNITARY(Oracle on 1) -&gt; UNITARY(Oracle on 2) -&gt; UNITARY(Oracle on 3) -&gt; SCATTERING -&gt; COIN -&gt; PROBA\n\n    \"\"\"\n    pipeline = qws.PipeLine(addressing_type=qws.AddressingType.NODE)\n    for m in marked:\n        pipeline.add_unitary([m], oracle, name=f\"Oracle on {m}\")\n    pipeline = pipeline + walk_on_nodes(scattering, coin=coin)\n    pipeline.add_proba(marked)\n    return pipeline\n</code></pre>"},{"location":"qwsearch/#qwgraph.pipelines.search_virtual_edges","title":"<code>search_virtual_edges(coin, scattering, marked, oracle=None)</code>","text":"<p>Create a default pipeline of a QW on edges searching nodes</p> <p>Parameters:</p> Name Type Description Default <code>coin</code> <code>numpy array</code> <p>coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.</p> required <code>scattering</code> <code>str</code> <p>\"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.</p> required <code>marked</code> <code>list</code> <p>the list of marked edges.</p> required <code>oracle</code> <code>numpy array</code> <p>The two by two unitary operator of the oracle. If None, then -X will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>(PipeLine)</code> <p>The pipeline of a QW on edges searching edges.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100), starify=True)\n&gt;&gt;&gt; search_virtual_edges(coins.X, \"grover\", qw.nodes()[0:4], -coins.X)\nUNITARY(Oracle on 0) -&gt; UNITARY(Oracle on 1) -&gt; UNITARY(Oracle on 2) -&gt; UNITARY(Oracle on 3) -&gt; COIN -&gt; SCATTERING -&gt; PROBA\n</code></pre> Source code in <code>qwgraph/pipelines.py</code> <pre><code>def search_virtual_edges(coin, scattering, marked, oracle=None):\n    \"\"\" Create a default pipeline of a QW on edges searching nodes\n\n    Args:\n        coin (numpy array): coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.\n        scattering (str): \"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.\n        marked (list): the list of marked edges.\n        oracle (numpy array, optional): The two by two unitary operator of the oracle. If None, then -X will be used.\n\n    Returns:\n        (PipeLine): The pipeline of a QW on edges searching edges.\n\n    Examples:\n        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100), starify=True)\n        &gt;&gt;&gt; search_virtual_edges(coins.X, \"grover\", qw.nodes()[0:4], -coins.X)\n        UNITARY(Oracle on 0) -&gt; UNITARY(Oracle on 1) -&gt; UNITARY(Oracle on 2) -&gt; UNITARY(Oracle on 3) -&gt; COIN -&gt; SCATTERING -&gt; PROBA\n\n    \"\"\"\n    pipeline = qws.PipeLine(addressing_type=qws.AddressingType.VIRTUAL_EDGE)\n    if type(oracle) == type(None):\n        oracle = -_X\n    for m in marked:\n        pipeline.add_unitary([m], oracle, name=f\"Oracle on {m}\")\n    pipeline = pipeline + walk_on_edges(coin, scattering)\n    pipeline.add_proba(marked)\n    return pipeline\n</code></pre>"},{"location":"qwsearch/#qwgraph.pipelines.walk_on_edges","title":"<code>walk_on_edges(coin, scattering)</code>","text":"<p>Create a default pipeline of a QW on edges</p> <p>Parameters:</p> Name Type Description Default <code>coin</code> <code>numpy array</code> <p>coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.</p> required <code>scattering</code> <code>str</code> <p>\"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.</p> required <p>Returns:</p> Type Description <code>(PipeLine)</code> <p>The pipeline of a QW on edges.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; walk_on_edges(coins.X,\"grover\")\nCOIN -&gt; SCATTERING\n</code></pre> Source code in <code>qwgraph/pipelines.py</code> <pre><code>def walk_on_edges(coin, scattering):\n    \"\"\" Create a default pipeline of a QW on edges\n\n    Args:\n        coin (numpy array): coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.\n        scattering (str): \"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.\n\n    Returns:\n        (PipeLine): The pipeline of a QW on edges.\n\n    Examples:\n        &gt;&gt;&gt; walk_on_edges(coins.X,\"grover\")\n        COIN -&gt; SCATTERING\n\n    \"\"\"\n    pipeline = qws.PipeLine(addressing_type=qws.AddressingType.EDGE)\n    pipeline.add_coin(coin)\n    pipeline.add_scattering(scattering)\n    return pipeline\n</code></pre>"},{"location":"qwsearch/#qwgraph.pipelines.walk_on_nodes","title":"<code>walk_on_nodes(scattering, coin=array([[0.+0.j, 1.+0.j],[1.+0.j, 0.+0.j]]))</code>","text":"<p>Create a default pipeline of a QW on nodes</p> <p>Parameters:</p> Name Type Description Default <code>scattering</code> <code>str</code> <p>\"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.</p> required <code>coin</code> <code>numpy array</code> <p>coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.</p> <code>array([[0.+0.j, 1.+0.j],        [1.+0.j, 0.+0.j]])</code> <p>Returns:</p> Type Description <code>(PipeLine)</code> <p>The pipeline of a QW on edges.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; walk_on_nodes(\"grover\")\nSCATTERING -&gt; COIN\n</code></pre> Source code in <code>qwgraph/pipelines.py</code> <pre><code>def walk_on_nodes(scattering, coin=_X):\n    \"\"\" Create a default pipeline of a QW on nodes\n\n    Args:\n        scattering (str): \"cycle\" for a cycle around the node or \"grover\" for a Grover diffusion around the node.\n        coin (numpy array, optional): coin (np.array or dict): The two by two matrix of the coin. Can alternatively be a dictionnary {edge : coin} for a coin dependent of the edge.\n\n    Returns:\n        (PipeLine): The pipeline of a QW on edges.\n\n    Examples:\n        &gt;&gt;&gt; walk_on_nodes(\"grover\")\n        SCATTERING -&gt; COIN\n\n    \"\"\"\n    pipeline = qws.PipeLine(addressing_type=qws.AddressingType.NODE)\n    pipeline.add_scattering(scattering)\n    pipeline.add_coin(coin)\n    return pipeline\n</code></pre>"}]}