
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../coins/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.6">
    
    
      
        <title>QWSearch - QWGraph Documentation v2.0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.50c56a3b.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#documentation-for-qwsearch" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="QWGraph Documentation v2.0" class="md-header__button md-logo" aria-label="QWGraph Documentation v2.0" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            QWGraph Documentation v2.0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              QWSearch
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="QWGraph Documentation v2.0" class="md-nav__button md-logo" aria-label="QWGraph Documentation v2.0" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    QWGraph Documentation v2.0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    QWSearch
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    QWSearch
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch" class="md-nav__link">
    <span class="md-ellipsis">
      QWSearch
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#getters" class="md-nav__link">
    <span class="md-ellipsis">
      Getters
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Getters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.graph" class="md-nav__link">
    <span class="md-ellipsis">
      graph()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.nodes" class="md-nav__link">
    <span class="md-ellipsis">
      nodes()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.edges" class="md-nav__link">
    <span class="md-ellipsis">
      edges()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.virtual_edges" class="md-nav__link">
    <span class="md-ellipsis">
      virtual_edges()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.color" class="md-nav__link">
    <span class="md-ellipsis">
      color()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.state" class="md-nav__link">
    <span class="md-ellipsis">
      state()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#setters" class="md-nav__link">
    <span class="md-ellipsis">
      Setters
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Setters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.set_state" class="md-nav__link">
    <span class="md-ellipsis">
      set_state()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.set_color" class="md-nav__link">
    <span class="md-ellipsis">
      set_color()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#simulation" class="md-nav__link">
    <span class="md-ellipsis">
      Simulation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Simulation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.run" class="md-nav__link">
    <span class="md-ellipsis">
      run()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.search" class="md-nav__link">
    <span class="md-ellipsis">
      search()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.get_T_P" class="md-nav__link">
    <span class="md-ellipsis">
      get_T_P()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#others" class="md-nav__link">
    <span class="md-ellipsis">
      Others
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Others">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.reset" class="md-nav__link">
    <span class="md-ellipsis">
      reset()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.get_proba" class="md-nav__link">
    <span class="md-ellipsis">
      get_proba()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.get_unitary" class="md-nav__link">
    <span class="md-ellipsis">
      get_unitary()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../coins/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Coins
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch" class="md-nav__link">
    <span class="md-ellipsis">
      QWSearch
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#getters" class="md-nav__link">
    <span class="md-ellipsis">
      Getters
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Getters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.graph" class="md-nav__link">
    <span class="md-ellipsis">
      graph()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.nodes" class="md-nav__link">
    <span class="md-ellipsis">
      nodes()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.edges" class="md-nav__link">
    <span class="md-ellipsis">
      edges()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.virtual_edges" class="md-nav__link">
    <span class="md-ellipsis">
      virtual_edges()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.color" class="md-nav__link">
    <span class="md-ellipsis">
      color()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.state" class="md-nav__link">
    <span class="md-ellipsis">
      state()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#setters" class="md-nav__link">
    <span class="md-ellipsis">
      Setters
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Setters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.set_state" class="md-nav__link">
    <span class="md-ellipsis">
      set_state()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.set_color" class="md-nav__link">
    <span class="md-ellipsis">
      set_color()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#simulation" class="md-nav__link">
    <span class="md-ellipsis">
      Simulation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Simulation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.run" class="md-nav__link">
    <span class="md-ellipsis">
      run()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.search" class="md-nav__link">
    <span class="md-ellipsis">
      search()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.get_T_P" class="md-nav__link">
    <span class="md-ellipsis">
      get_T_P()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#others" class="md-nav__link">
    <span class="md-ellipsis">
      Others
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Others">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.reset" class="md-nav__link">
    <span class="md-ellipsis">
      reset()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.get_proba" class="md-nav__link">
    <span class="md-ellipsis">
      get_proba()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qwgraph.qwsearch.QWSearch.get_unitary" class="md-nav__link">
    <span class="md-ellipsis">
      get_unitary()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="documentation-for-qwsearch">Documentation for QWSearch</h1>
<p>The class <code>qwgraph.QWSearch</code> contains everything to create and run quantum walks or search based quantum walks.
In order to specify the underlying graph of the QW, the use of networkx is required.</p>


  <div class="doc doc-object doc-class">



<h3 id="qwgraph.qwsearch.QWSearch" class="doc doc-heading">
        <code>
QWSearch        </code>



</h3>

    <div class="doc doc-contents first">

      <p>The Quantum Walk based search class. An instance of this class will be a Quantum Walk on a given graph.
Methods are provided to modify and access the QW state and to run the QWSearch.</p>
<p>Both the Quantum Walk and searching process are described in https://arxiv.org/abs/2310.10451</p>

<p><strong>Attributes:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>step</code></td>
        <td><code>int</code></td>
        <td><p>The current step (or epoch). Modifying this attribute will only change the step column of the <code>search</code> method.</p></td>
      </tr>
  </tbody>
</table>
<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>graph</code></td>
        <td><code>networkx.Graph</code></td>
        <td><p>The graph on which the QW will be defined.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>search_nodes</code></td>
        <td><code>bool</code></td>
        <td><p>If True, the graph will be starified and the QW will be tuned to search nodes instead of edges. </p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">QWSearch</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    The Quantum Walk based search class. An instance of this class will be a Quantum Walk on a given graph.</span>
<span class="sd">    Methods are provided to modify and access the QW state and to run the QWSearch.</span>

<span class="sd">    Both the Quantum Walk and searching process are described in https://arxiv.org/abs/2310.10451</span>

<span class="sd">    Attributes:</span>
<span class="sd">        step (int): The current step (or epoch). Modifying this attribute will only change the step column of the `search` method.</span>

<span class="sd">    Args:</span>
<span class="sd">        graph (networkx.Graph): The graph on which the QW will be defined.</span>
<span class="sd">        search_nodes (bool, optional): If True, the graph will be starified and the QW will be tuned to search nodes instead of edges. </span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">search_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__search_nodes</span> <span class="o">=</span> <span class="n">search_nodes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__search_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__virtual_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__starify</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__virtual_edges</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="c1"># List of edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="c1"># List of nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">))}</span> <span class="c1"># Index for edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__E</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">)</span> <span class="c1"># Number of edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span> <span class="c1"># Number of nodes</span>

        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">bipartite</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="p">):</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">bipartite</span><span class="o">.</span><span class="n">color</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="p">)</span> <span class="c1"># Coloring</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">))}</span> <span class="c1"># Coloring</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">__initalize_rust_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__amplitude_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span>
        <span class="n">wiring</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># For any amplitude self.state[i], says to which node it is connected. Important for the scattering.</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">i</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__N</span><span class="p">)}</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">:</span>
            <span class="n">edge_label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__color</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">wiring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">wiring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__amplitude_labels</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;$\psi_{&quot;</span><span class="o">+</span><span class="n">edge_label</span><span class="o">+</span><span class="s2">&quot;}^-$&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__amplitude_labels</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;$\psi_{&quot;</span><span class="o">+</span><span class="n">edge_label</span><span class="o">+</span><span class="s2">&quot;}^+$&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wiring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">wiring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__amplitude_labels</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;$\psi_{&quot;</span><span class="o">+</span><span class="n">edge_label</span><span class="o">+</span><span class="s2">&quot;}^+$&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__amplitude_labels</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;$\psi_{&quot;</span><span class="o">+</span><span class="n">edge_label</span><span class="o">+</span><span class="s2">&quot;}^-$&quot;</span>
            <span class="n">k</span><span class="o">+=</span><span class="mi">2</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span> <span class="o">=</span> <span class="n">qwfast</span><span class="o">.</span><span class="n">QWFast</span><span class="p">(</span><span class="n">wiring</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__N</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">__starify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;new_node</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;new_node</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the list of nodes. Convenient when declaring which nodes are marked.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list of node): The list of nodes of the underlying graph.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">            &gt;&gt;&gt; qw.nodes()</span>
<span class="sd">            [0, 1, 2, 3]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the list of edges. Convenient when declaring which edges are marked.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list of edge): The list of edges of the underlying graph.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">            &gt;&gt;&gt; qw.edges()</span>
<span class="sd">            [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the underlying graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (networkx.Graph): The underlying graph.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">            &gt;&gt;&gt; qw.graph()</span>
<span class="sd">            &lt;networkx.classes.graph.Graph at 0x7bd045d53c70&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">virtual_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns a dictionnary that associates its virtual edge to each node. This dictionnary is empty when the object has been built with `search_nodes==False` since there are no virtual edges in that case.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (dict): A dictionnary {node: edge} that associates each node to its virtual edge.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">            &gt;&gt;&gt; qw.virtual_edges()</span>
<span class="sd">            {}</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4),search_nodes=True)</span>
<span class="sd">            &gt;&gt;&gt; qw.virtual_edges()</span>
<span class="sd">            {0: (0, &#39;new_node0&#39;),</span>
<span class="sd">             1: (1, &#39;new_node1&#39;),</span>
<span class="sd">             2: (2, &#39;new_node2&#39;),</span>
<span class="sd">             3: (3, &#39;new_node3&#39;)}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__virtual_edges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the coloring of the underlying graph. This coloring is essential for the QW to be well defined.</span>

<span class="sd">        The coloring is calculated when the object is built. Two cases are possible:</span>

<span class="sd">        1. The graph passed to the constructor is bipartite. In this case, a 2-coloring is computed.</span>

<span class="sd">        2. The graph isn&#39;t bipartite. In that case, the coloring is chosen to be the trivial one. Every node has a unique number, which is its color. </span>

<span class="sd">        Returns:</span>
<span class="sd">            (dict): A dictionnary {node: color} that associates a color to each node.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))</span>
<span class="sd">            &gt;&gt;&gt; qw.color()</span>
<span class="sd">            {0: 1, 1: 0, 3: 0, 2: 1}</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))</span>
<span class="sd">            &gt;&gt;&gt; qw.color()</span>
<span class="sd">            {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__color</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Modifies the coloring of the graph. </span>
<span class="sd">        Since the coloring is essential to the definition of the QW, modifying it will reinitialize the inner state to the diagonal one. Essentially, the method set_color calls the method reset.</span>

<span class="sd">        Args:</span>
<span class="sd">            color (dict): The new coloring for the underlying graph. Must be a dictionnary node:color</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))</span>
<span class="sd">            &gt;&gt;&gt; qw.color()</span>
<span class="sd">            {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}</span>
<span class="sd">            &gt;&gt;&gt; qw.set_color(nx.greedy_color(qw.graph()))</span>
<span class="sd">            &gt;&gt;&gt; qw.color()</span>
<span class="sd">            {0: 0, 1: 1, 2: 0, 3: 1, 4: 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__color</span> <span class="o">=</span> <span class="n">color</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__color</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initalize_rust_object</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the amplitudes of one/several/every edges.</span>

<span class="sd">        For an edge (u,v), the amplitudes $\psi_{u,v}^+$ and $\psi_{u,v}^-$ will be returned in the form of a numpy array.</span>

<span class="sd">        Args:</span>
<span class="sd">            edges (list, optional): The list of edges for which we want to extract the amplitudes. If None, all the edges are extracted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (dict): A dictionnary edge:amplitudes where the amplitudes are complex numpy arrays of dimension 2.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))</span>
<span class="sd">            &gt;&gt;&gt; qw.state()</span>
<span class="sd">            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>
<span class="sd">            &gt;&gt;&gt; qw.state(qw.edges()[0:2])</span>
<span class="sd">            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (0, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__edges</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_edge_index</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dic</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dic</span>

    <span class="k">def</span> <span class="nf">set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Change the inner state (i.e. the amplitudes for every edges).</span>

<span class="sd">        For an edge (u,v), the amplitudes $\psi_{u,v}^+$ and $\psi_{u,v}^-$ will be modified according to the argument.</span>
<span class="sd">        If the new state is not normalized, this method will automatically normalize it.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_state (dict): A dictionnary of the form edge: amplitudes. Amplitudes must be numpy arrays or lists of dimension 2.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))</span>
<span class="sd">            &gt;&gt;&gt; qw.state()</span>
<span class="sd">            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>
<span class="sd">            &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})</span>
<span class="sd">            &gt;&gt;&gt; qw.state()</span>
<span class="sd">            {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">             (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">             (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">             (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">new_state</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">new_state</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">new_state</span><span class="p">]))</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">):</span>
            <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">s</span>
            <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>


    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reset the state to a diagonal one and reset the current step to 0.</span>
<span class="sd">        Do not return anything.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))</span>
<span class="sd">            &gt;&gt;&gt; qw.state()</span>
<span class="sd">            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>
<span class="sd">            &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})</span>
<span class="sd">            &gt;&gt;&gt; qw.state()</span>
<span class="sd">            {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">             (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">             (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">             (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}</span>
<span class="sd">            &gt;&gt;&gt; qw.reset()</span>
<span class="sd">            &gt;&gt;&gt; qw.state()</span>
<span class="sd">            {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">             (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">__get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">searched</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__search_nodes</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__virtual_edges</span><span class="p">[</span><span class="n">searched</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">searched</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">edge</span><span class="p">,</span><span class="n">index</span>


    <span class="k">def</span> <span class="nf">get_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">searched</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the probability to measure on of the searched element.</span>

<span class="sd">        Args:   </span>
<span class="sd">            searched (list of edge): The list of marked edges. Every element of the list must be an edge label (all of them are listed in `qw.edges`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float): The probability of measuring any of the marked edges.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">            &gt;&gt;&gt; qw.get_proba([qw.edges()[0]])</span>
<span class="sd">            0.1666666666666667</span>
<span class="sd">            &gt;&gt;&gt; qw.get_proba([qw.edges()[0],qw.edges()[1]])</span>
<span class="sd">            0.3333333333333334</span>
<span class="sd">            &gt;&gt;&gt; qw.get_proba(qw.edges())</span>
<span class="sd">            1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_edge_index</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Run the simulation with coin `C`, oracle `R` for ticks steps and with searched elements `search`.</span>
<span class="sd">        Nothing will be returned but the inner state will be modified inplace.</span>

<span class="sd">        Args:</span>
<span class="sd">            C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.</span>
<span class="sd">            R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.</span>
<span class="sd">            searched (list, optional): The list of marked elements. &quot;elements&quot; here means nodes if search_nodes was true when building the object, and means edges otherwise.</span>
<span class="sd">            ticks (int, optional): The number of time steps.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(6))</span>
<span class="sd">            &gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})</span>
<span class="sd">            &gt;&gt;&gt; [qw.get_proba([e]) for e in qw.edges()]</span>
<span class="sd">            [0.0, 0.0, 0.0, 1.0, 0.0, 0.0]</span>
<span class="sd">            &gt;&gt;&gt; qw.run(coins.H,coins.I,ticks=3)</span>
<span class="sd">            &gt;&gt;&gt; [np.round(qw.get_proba([e]),3) for e in qw.edges()]</span>
<span class="sd">            [0.0, 0.25, 0.625, 0.0, 0.125, 0.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">ticks</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_edge_index</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">+=</span><span class="n">ticks</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Run the simulation with coin `C`, oracle `R` for ticks steps and with searched elements `searched`.</span>

<span class="sd">        This method does the same thing than `run`, but returns the probability of success at every steps. For every marked element m, the probability of measuring m at every step is returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.</span>
<span class="sd">            R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.</span>
<span class="sd">            searched (list, optional): The list of marked elements. &quot;elements&quot; here means nodes if search_nodes was true when building the object, and means edges otherwise.</span>
<span class="sd">            ticks (int, optional): The number of time steps.</span>
<span class="sd">            progress (bool, optional): If True, a tqdm progress bar will be displayed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (pandas.DataFrame): A dataframe containing probabilities fo measuring marked positions. The column &quot;step&quot; denote the step number (or epoch) of the dynamic. For each marked element `m`, the column `m` denotes the probability of measuring `m` at any given step. The column `p_succ` denotes the probability of measuring any marked elements and is essentially the sum of all the other colmuns excepted &quot;step&quot;.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))</span>
<span class="sd">            &gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.edges()[0:4],ticks=10))</span>
<span class="sd">                step    p_succ    (0, 1)    (0, 2)    (0, 3)    (0, 4)</span>
<span class="sd">            0      0  0.000808  0.000202  0.000202  0.000202  0.000202</span>
<span class="sd">            1      1  0.003880  0.000994  0.000978  0.000962  0.000946</span>
<span class="sd">            2      2  0.009113  0.002467  0.002337  0.002214  0.002095</span>
<span class="sd">            3      3  0.013043  0.003875  0.003441  0.003044  0.002683</span>
<span class="sd">            4      4  0.013292  0.004433  0.003617  0.002918  0.002324</span>
<span class="sd">            5      5  0.010471  0.003820  0.002892  0.002162  0.001596</span>
<span class="sd">            6      6  0.007487  0.002620  0.002011  0.001579  0.001277</span>
<span class="sd">            7      7  0.005653  0.001645  0.001455  0.001324  0.001228</span>
<span class="sd">            8      8  0.004657  0.001321  0.001212  0.001107  0.001017</span>
<span class="sd">            9      9  0.004065  0.001494  0.001105  0.000824  0.000641</span>
<span class="sd">            10    10  0.004440  0.001913  0.001226  0.000784  0.000517</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100),search_nodes=True)</span>
<span class="sd">            &gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.nodes()[0:4],ticks=10))</span>
<span class="sd">                step    p_succ         0         1         2         3</span>
<span class="sd">            0      0  0.000792  0.000198  0.000198  0.000198  0.000198</span>
<span class="sd">            1      1  0.000746  0.000198  0.000190  0.000182  0.000175</span>
<span class="sd">            2      2  0.003557  0.000978  0.000917  0.000859  0.000803</span>
<span class="sd">            3      3  0.000890  0.000280  0.000237  0.000201  0.000172</span>
<span class="sd">            4      4  0.000097  0.000023  0.000020  0.000023  0.000031</span>
<span class="sd">            5      5  0.000320  0.000072  0.000079  0.000084  0.000086</span>
<span class="sd">            6      6  0.004178  0.001147  0.001087  0.001014  0.000930</span>
<span class="sd">            7      7  0.002613  0.000864  0.000713  0.000577  0.000459</span>
<span class="sd">            8      8  0.002197  0.000817  0.000607  0.000446  0.000327</span>
<span class="sd">            9      9  0.002605  0.000897  0.000695  0.000554  0.000458</span>
<span class="sd">            10    10  0.000085  0.000036  0.000022  0.000015  0.000012</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;p_succ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_proba</span><span class="p">(</span><span class="n">searched</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="n">i</span><span class="p">])]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ticks</span><span class="p">)))</span> <span class="k">if</span> <span class="n">progress</span> <span class="k">else</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ticks</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">searched</span><span class="o">=</span><span class="n">searched</span><span class="p">)</span>

            <span class="n">p</span><span class="p">[</span><span class="s2">&quot;p_succ&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_proba</span><span class="p">(</span><span class="n">searched</span><span class="p">))</span>
            <span class="n">p</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">:</span>
                <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_unitary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">dataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; For a given coin, oracle and set of searched edges, compute and return the unitary U coresponding to one step of the QW.</span>

<span class="sd">        This method **do not** change the state of the QW.</span>

<span class="sd">        Args:</span>
<span class="sd">            C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.</span>
<span class="sd">            R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.</span>
<span class="sd">            searched (list, optional): The list of marked elements. &quot;elements&quot; here means nodes if search_nodes was true when building the object, and means edges otherwise.</span>
<span class="sd">            dataframe (bool, optional): If True, the result will be a pandas dataframe instead of a numpy array. </span>
<span class="sd">            progress (bool, optional): If True, a tqdm progress bar will be displayed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy array or pandas dataframe): The unitary operator coresponding to one step of the dynamic. If dataframe is set to True, a pandas dataframe will be returned instead.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(3))</span>
<span class="sd">            &gt;&gt;&gt; qw.get_unitary(coins.H,coins.I)</span>
<span class="sd">            array([[ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,</span>
<span class="sd">                     0.70710678+0.j,  0.        +0.j,  0.        +0.j],</span>
<span class="sd">                   [ 0.        +0.j,  0.        +0.j,  0.        +0.j,</span>
<span class="sd">                     0.        +0.j,  0.70710678+0.j,  0.70710678+0.j],</span>
<span class="sd">                   [ 0.70710678+0.j,  0.70710678+0.j,  0.        +0.j,</span>
<span class="sd">                     0.        +0.j,  0.        +0.j,  0.        +0.j],</span>
<span class="sd">                   [ 0.        +0.j,  0.        +0.j,  0.        +0.j,</span>
<span class="sd">                     0.        +0.j,  0.70710678+0.j, -0.70710678+0.j],</span>
<span class="sd">                   [ 0.70710678+0.j, -0.70710678+0.j,  0.        +0.j,</span>
<span class="sd">                     0.        +0.j,  0.        +0.j,  0.        +0.j],</span>
<span class="sd">                   [ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,</span>
<span class="sd">                    -0.70710678+0.j,  0.        +0.j,  0.        +0.j]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_state</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
        <span class="n">old_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span>
        <span class="n">U</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">),</span><span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">))</span> <span class="k">if</span> <span class="n">progress</span> <span class="k">else</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="n">searched</span><span class="p">)</span>
            <span class="n">U</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">old_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">old_step</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dataframe</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__amplitude_labels</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__amplitude_labels</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">U</span>

    <span class="k">def</span> <span class="nf">get_T_P</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">waiting</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Computes the hitting time and probability of success for a given QW. </span>

<span class="sd">        The waiting parameter is used to accumalate informations about the signal (recommended to be at least 10).</span>

<span class="sd">        In details, this algorithm look at the time serie of the probability of success $p(t)$. </span>
<span class="sd">        At any time step $t$, we define $T_{max}(t) = \\underset{{t&#39; \\leq t}}{\\mathrm{argmax }}\\; p(t&#39;)$ and $T_{min}(t) = \\underset{{t&#39; \\leq t}}{\\mathrm{argmin }} \\; p(t&#39;)$.</span>

<span class="sd">        The algorithms computes the series $p(t)$, $T_{max}(t)$, $T_{min}(t)$ and stop when it encounters `t&gt;waiting` such that $p(t)&lt;\\frac{p\\left(T_{max}(t)\\right)+p\\left(T_{max}(t)\\right)}{2}$. </span>
<span class="sd">        It then returns $T_{max}(t), p\\left(T_{max}(t)\\right)$.</span>

<span class="sd">        **Warning:** This function will reset the state of the QW.</span>

<span class="sd">        Args:</span>
<span class="sd">            C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.</span>
<span class="sd">            R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.</span>
<span class="sd">            searched (list, optional): The list of marked elements. &quot;elements&quot; here means nodes if search_nodes was true when building the object, and means edges otherwise.</span>
<span class="sd">            waiting (int, optional): The waiting time for the algorithm. Must be smaller than the hitting time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int*float): T:int,P:float respectively the hitting time and probability of success.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))</span>
<span class="sd">            &gt;&gt;&gt; qw.get_T_P(coins.X,-coins.X,searched=qw.edges()[0:4])</span>
<span class="sd">            (28, 0.9565191408575295)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">carac</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">R</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_edge_index</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">],</span><span class="n">waiting</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>
</code></pre></div>
        </details>


    </div>

  </div>

<hr />
<h2 id="getters">Getters</h2>


  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.graph" class="doc doc-heading">
<code class="highlight language-python"><span class="n">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Returns the underlying graph.</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(networkx.Graph)</code></td>
      <td><p>The underlying graph.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">networkx</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">Graph</span> <span class="n">at</span> <span class="mh">0x7bd045d53c70</span><span class="o">&gt;</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Returns the underlying graph.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (networkx.Graph): The underlying graph.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">        &gt;&gt;&gt; qw.graph()</span>
<span class="sd">        &lt;networkx.classes.graph.Graph at 0x7bd045d53c70&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.nodes" class="doc doc-heading">
<code class="highlight language-python"><span class="n">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Returns the list of nodes. Convenient when declaring which nodes are marked.</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(list of node)</code></td>
      <td><p>The list of nodes of the underlying graph.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Returns the list of nodes. Convenient when declaring which nodes are marked.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (list of node): The list of nodes of the underlying graph.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">        &gt;&gt;&gt; qw.nodes()</span>
<span class="sd">        [0, 1, 2, 3]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.edges" class="doc doc-heading">
<code class="highlight language-python"><span class="n">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Returns the list of edges. Convenient when declaring which edges are marked.</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(list of edge)</code></td>
      <td><p>The list of edges of the underlying graph.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Returns the list of edges. Convenient when declaring which edges are marked.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (list of edge): The list of edges of the underlying graph.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">        &gt;&gt;&gt; qw.edges()</span>
<span class="sd">        [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.virtual_edges" class="doc doc-heading">
<code class="highlight language-python"><span class="n">virtual_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Returns a dictionnary that associates its virtual edge to each node. This dictionnary is empty when the object has been built with <code>search_nodes==False</code> since there are no virtual edges in that case.</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(dict)</code></td>
      <td><p>A dictionnary {node: edge} that associates each node to its virtual edge.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">virtual_edges</span><span class="p">()</span>
<span class="p">{}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="n">search_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">virtual_edges</span><span class="p">()</span>
<span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;new_node0&#39;</span><span class="p">),</span>
 <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;new_node1&#39;</span><span class="p">),</span>
 <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;new_node2&#39;</span><span class="p">),</span>
 <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;new_node3&#39;</span><span class="p">)}</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">virtual_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Returns a dictionnary that associates its virtual edge to each node. This dictionnary is empty when the object has been built with `search_nodes==False` since there are no virtual edges in that case.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (dict): A dictionnary {node: edge} that associates each node to its virtual edge.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">        &gt;&gt;&gt; qw.virtual_edges()</span>
<span class="sd">        {}</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4),search_nodes=True)</span>
<span class="sd">        &gt;&gt;&gt; qw.virtual_edges()</span>
<span class="sd">        {0: (0, &#39;new_node0&#39;),</span>
<span class="sd">         1: (1, &#39;new_node1&#39;),</span>
<span class="sd">         2: (2, &#39;new_node2&#39;),</span>
<span class="sd">         3: (3, &#39;new_node3&#39;)}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__virtual_edges</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.color" class="doc doc-heading">
<code class="highlight language-python"><span class="n">color</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Returns the coloring of the underlying graph. This coloring is essential for the QW to be well defined.</p>
<p>The coloring is calculated when the object is built. Two cases are possible:</p>
<ol>
<li>
<p>The graph passed to the constructor is bipartite. In this case, a 2-coloring is computed.</p>
</li>
<li>
<p>The graph isn't bipartite. In that case, the coloring is chosen to be the trivial one. Every node has a unique number, which is its color. </p>
</li>
</ol>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(dict)</code></td>
      <td><p>A dictionnary {node: color} that associates a color to each node.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">color</span><span class="p">()</span>
<span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">color</span><span class="p">()</span>
<span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Returns the coloring of the underlying graph. This coloring is essential for the QW to be well defined.</span>

<span class="sd">    The coloring is calculated when the object is built. Two cases are possible:</span>

<span class="sd">    1. The graph passed to the constructor is bipartite. In this case, a 2-coloring is computed.</span>

<span class="sd">    2. The graph isn&#39;t bipartite. In that case, the coloring is chosen to be the trivial one. Every node has a unique number, which is its color. </span>

<span class="sd">    Returns:</span>
<span class="sd">        (dict): A dictionnary {node: color} that associates a color to each node.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))</span>
<span class="sd">        &gt;&gt;&gt; qw.color()</span>
<span class="sd">        {0: 1, 1: 0, 3: 0, 2: 1}</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))</span>
<span class="sd">        &gt;&gt;&gt; qw.color()</span>
<span class="sd">        {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__color</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.state" class="doc doc-heading">
<code class="highlight language-python"><span class="n">state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Return the amplitudes of one/several/every edges.</p>
<p>For an edge (u,v), the amplitudes <span class="arithmatex">\(\psi_{u,v}^+\)</span> and <span class="arithmatex">\(\psi_{u,v}^-\)</span> will be returned in the form of a numpy array.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>edges</code></td>
        <td><code>list</code></td>
        <td><p>The list of edges for which we want to extract the amplitudes. If None, all the edges are extracted.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(dict)</code></td>
      <td><p>A dictionnary edge:amplitudes where the amplitudes are complex numpy arrays of dimension 2.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
<span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])}</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the amplitudes of one/several/every edges.</span>

<span class="sd">    For an edge (u,v), the amplitudes $\psi_{u,v}^+$ and $\psi_{u,v}^-$ will be returned in the form of a numpy array.</span>

<span class="sd">    Args:</span>
<span class="sd">        edges (list, optional): The list of edges for which we want to extract the amplitudes. If None, all the edges are extracted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (dict): A dictionnary edge:amplitudes where the amplitudes are complex numpy arrays of dimension 2.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))</span>
<span class="sd">        &gt;&gt;&gt; qw.state()</span>
<span class="sd">        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>
<span class="sd">        &gt;&gt;&gt; qw.state(qw.edges()[0:2])</span>
<span class="sd">        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (0, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__edges</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_edge_index</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dic</span>
</code></pre></div>
        </details>
    </div>

  </div>

<h2 id="setters">Setters</h2>


  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.set_state" class="doc doc-heading">
<code class="highlight language-python"><span class="n">set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_state</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Change the inner state (i.e. the amplitudes for every edges).</p>
<p>For an edge (u,v), the amplitudes <span class="arithmatex">\(\psi_{u,v}^+\)</span> and <span class="arithmatex">\(\psi_{u,v}^-\)</span> will be modified according to the argument.
If the new state is not normalized, this method will automatically normalize it.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>new_state</code></td>
        <td><code>dict</code></td>
        <td><p>A dictionnary of the form edge: amplitudes. Amplitudes must be numpy arrays or lists of dimension 2.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">set_state</span><span class="p">({</span><span class="n">edge</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.4472136</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>       <span class="p">,</span> <span class="mf">0.</span>       <span class="o">+</span><span class="mf">0.2236068</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.4472136</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>       <span class="p">,</span> <span class="mf">0.</span>       <span class="o">+</span><span class="mf">0.2236068</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.4472136</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>       <span class="p">,</span> <span class="mf">0.</span>       <span class="o">+</span><span class="mf">0.2236068</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.4472136</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>       <span class="p">,</span> <span class="mf">0.</span>       <span class="o">+</span><span class="mf">0.2236068</span><span class="n">j</span><span class="p">])}</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_state</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Change the inner state (i.e. the amplitudes for every edges).</span>

<span class="sd">    For an edge (u,v), the amplitudes $\psi_{u,v}^+$ and $\psi_{u,v}^-$ will be modified according to the argument.</span>
<span class="sd">    If the new state is not normalized, this method will automatically normalize it.</span>

<span class="sd">    Args:</span>
<span class="sd">        new_state (dict): A dictionnary of the form edge: amplitudes. Amplitudes must be numpy arrays or lists of dimension 2.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))</span>
<span class="sd">        &gt;&gt;&gt; qw.state()</span>
<span class="sd">        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>
<span class="sd">        &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})</span>
<span class="sd">        &gt;&gt;&gt; qw.state()</span>
<span class="sd">        {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">         (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">         (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">         (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">new_state</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">new_state</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">new_state</span><span class="p">]))</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">):</span>
        <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">s</span>
        <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__edges</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">s</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.set_color" class="doc doc-heading">
<code class="highlight language-python"><span class="n">set_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Modifies the coloring of the graph. 
Since the coloring is essential to the definition of the QW, modifying it will reinitialize the inner state to the diagonal one. Essentially, the method set_color calls the method reset.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>color</code></td>
        <td><code>dict</code></td>
        <td><p>The new coloring for the underlying graph. Must be a dictionnary node:color</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">color</span><span class="p">()</span>
<span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">greedy_color</span><span class="p">(</span><span class="n">qw</span><span class="o">.</span><span class="n">graph</span><span class="p">()))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">color</span><span class="p">()</span>
<span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">set_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Modifies the coloring of the graph. </span>
<span class="sd">    Since the coloring is essential to the definition of the QW, modifying it will reinitialize the inner state to the diagonal one. Essentially, the method set_color calls the method reset.</span>

<span class="sd">    Args:</span>
<span class="sd">        color (dict): The new coloring for the underlying graph. Must be a dictionnary node:color</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(5))</span>
<span class="sd">        &gt;&gt;&gt; qw.color()</span>
<span class="sd">        {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}</span>
<span class="sd">        &gt;&gt;&gt; qw.set_color(nx.greedy_color(qw.graph()))</span>
<span class="sd">        &gt;&gt;&gt; qw.color()</span>
<span class="sd">        {0: 0, 1: 1, 2: 0, 3: 1, 4: 2}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__color</span> <span class="o">=</span> <span class="n">color</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__color</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__initalize_rust_object</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>

<h2 id="simulation">Simulation</h2>


  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.run" class="doc doc-heading">
<code class="highlight language-python"><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Run the simulation with coin <code>C</code>, oracle <code>R</code> for ticks steps and with searched elements <code>search</code>.
Nothing will be returned but the inner state will be modified inplace.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>C</code></td>
        <td><code>numpy.array of complex</code></td>
        <td><p>The coin defined as a 2x2 numpy array of complex.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>R</code></td>
        <td><code>numpy.array of complex</code></td>
        <td><p>The oracle defined as a 2x2 numpy array of complex.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>searched</code></td>
        <td><code>list</code></td>
        <td><p>The list of marked elements. "elements" here means nodes if search_nodes was true when building the object, and means edges otherwise.</p></td>
        <td><code>[]</code></td>
      </tr>
      <tr>
        <td><code>ticks</code></td>
        <td><code>int</code></td>
        <td><p>The number of time steps.</p></td>
        <td><code>1</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">set_state</span><span class="p">({</span><span class="n">edge</span><span class="p">:([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">edge</span><span class="o">==</span><span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="nb">len</span><span class="p">(</span><span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">qw</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">coins</span><span class="o">.</span><span class="n">H</span><span class="p">,</span><span class="n">coins</span><span class="o">.</span><span class="n">I</span><span class="p">,</span><span class="n">ticks</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">qw</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="n">e</span><span class="p">]),</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Run the simulation with coin `C`, oracle `R` for ticks steps and with searched elements `search`.</span>
<span class="sd">    Nothing will be returned but the inner state will be modified inplace.</span>

<span class="sd">    Args:</span>
<span class="sd">        C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.</span>
<span class="sd">        R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.</span>
<span class="sd">        searched (list, optional): The list of marked elements. &quot;elements&quot; here means nodes if search_nodes was true when building the object, and means edges otherwise.</span>
<span class="sd">        ticks (int, optional): The number of time steps.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(6))</span>
<span class="sd">        &gt;&gt;&gt; qw.set_state({edge:([1,0] if edge==qw.edges()[len(qw.edges())//2] else [0,0]) for edge in qw.edges()})</span>
<span class="sd">        &gt;&gt;&gt; [qw.get_proba([e]) for e in qw.edges()]</span>
<span class="sd">        [0.0, 0.0, 0.0, 1.0, 0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; qw.run(coins.H,coins.I,ticks=3)</span>
<span class="sd">        &gt;&gt;&gt; [np.round(qw.get_proba([e]),3) for e in qw.edges()]</span>
<span class="sd">        [0.0, 0.25, 0.625, 0.0, 0.125, 0.0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">ticks</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_edge_index</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">+=</span><span class="n">ticks</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.search" class="doc doc-heading">
<code class="highlight language-python"><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Run the simulation with coin <code>C</code>, oracle <code>R</code> for ticks steps and with searched elements <code>searched</code>.</p>
<p>This method does the same thing than <code>run</code>, but returns the probability of success at every steps. For every marked element m, the probability of measuring m at every step is returned.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>C</code></td>
        <td><code>numpy.array of complex</code></td>
        <td><p>The coin defined as a 2x2 numpy array of complex.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>R</code></td>
        <td><code>numpy.array of complex</code></td>
        <td><p>The oracle defined as a 2x2 numpy array of complex.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>searched</code></td>
        <td><code>list</code></td>
        <td><p>The list of marked elements. "elements" here means nodes if search_nodes was true when building the object, and means edges otherwise.</p></td>
        <td><code>[]</code></td>
      </tr>
      <tr>
        <td><code>ticks</code></td>
        <td><code>int</code></td>
        <td><p>The number of time steps.</p></td>
        <td><code>1</code></td>
      </tr>
      <tr>
        <td><code>progress</code></td>
        <td><code>bool</code></td>
        <td><p>If True, a tqdm progress bar will be displayed.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(pandas.DataFrame)</code></td>
      <td><p>A dataframe containing probabilities fo measuring marked positions. The column "step" denote the step number (or epoch) of the dynamic. For each marked element <code>m</code>, the column <code>m</code> denotes the probability of measuring <code>m</code> at any given step. The column <code>p_succ</code> denotes the probability of measuring any marked elements and is essentially the sum of all the other colmuns excepted "step".</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">qw</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">coins</span><span class="o">.</span><span class="n">H</span><span class="p">,</span><span class="n">coins</span><span class="o">.</span><span class="n">I</span><span class="p">,</span><span class="n">searched</span><span class="o">=</span><span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="n">ticks</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">step</span>    <span class="n">p_succ</span>    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">0</span>      <span class="mi">0</span>  <span class="mf">0.000808</span>  <span class="mf">0.000202</span>  <span class="mf">0.000202</span>  <span class="mf">0.000202</span>  <span class="mf">0.000202</span>
<span class="mi">1</span>      <span class="mi">1</span>  <span class="mf">0.003880</span>  <span class="mf">0.000994</span>  <span class="mf">0.000978</span>  <span class="mf">0.000962</span>  <span class="mf">0.000946</span>
<span class="mi">2</span>      <span class="mi">2</span>  <span class="mf">0.009113</span>  <span class="mf">0.002467</span>  <span class="mf">0.002337</span>  <span class="mf">0.002214</span>  <span class="mf">0.002095</span>
<span class="mi">3</span>      <span class="mi">3</span>  <span class="mf">0.013043</span>  <span class="mf">0.003875</span>  <span class="mf">0.003441</span>  <span class="mf">0.003044</span>  <span class="mf">0.002683</span>
<span class="mi">4</span>      <span class="mi">4</span>  <span class="mf">0.013292</span>  <span class="mf">0.004433</span>  <span class="mf">0.003617</span>  <span class="mf">0.002918</span>  <span class="mf">0.002324</span>
<span class="mi">5</span>      <span class="mi">5</span>  <span class="mf">0.010471</span>  <span class="mf">0.003820</span>  <span class="mf">0.002892</span>  <span class="mf">0.002162</span>  <span class="mf">0.001596</span>
<span class="mi">6</span>      <span class="mi">6</span>  <span class="mf">0.007487</span>  <span class="mf">0.002620</span>  <span class="mf">0.002011</span>  <span class="mf">0.001579</span>  <span class="mf">0.001277</span>
<span class="mi">7</span>      <span class="mi">7</span>  <span class="mf">0.005653</span>  <span class="mf">0.001645</span>  <span class="mf">0.001455</span>  <span class="mf">0.001324</span>  <span class="mf">0.001228</span>
<span class="mi">8</span>      <span class="mi">8</span>  <span class="mf">0.004657</span>  <span class="mf">0.001321</span>  <span class="mf">0.001212</span>  <span class="mf">0.001107</span>  <span class="mf">0.001017</span>
<span class="mi">9</span>      <span class="mi">9</span>  <span class="mf">0.004065</span>  <span class="mf">0.001494</span>  <span class="mf">0.001105</span>  <span class="mf">0.000824</span>  <span class="mf">0.000641</span>
<span class="mi">10</span>    <span class="mi">10</span>  <span class="mf">0.004440</span>  <span class="mf">0.001913</span>  <span class="mf">0.001226</span>  <span class="mf">0.000784</span>  <span class="mf">0.000517</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span><span class="n">search_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">qw</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">coins</span><span class="o">.</span><span class="n">H</span><span class="p">,</span><span class="n">coins</span><span class="o">.</span><span class="n">I</span><span class="p">,</span><span class="n">searched</span><span class="o">=</span><span class="n">qw</span><span class="o">.</span><span class="n">nodes</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="n">ticks</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">step</span>    <span class="n">p_succ</span>         <span class="mi">0</span>         <span class="mi">1</span>         <span class="mi">2</span>         <span class="mi">3</span>
<span class="mi">0</span>      <span class="mi">0</span>  <span class="mf">0.000792</span>  <span class="mf">0.000198</span>  <span class="mf">0.000198</span>  <span class="mf">0.000198</span>  <span class="mf">0.000198</span>
<span class="mi">1</span>      <span class="mi">1</span>  <span class="mf">0.000746</span>  <span class="mf">0.000198</span>  <span class="mf">0.000190</span>  <span class="mf">0.000182</span>  <span class="mf">0.000175</span>
<span class="mi">2</span>      <span class="mi">2</span>  <span class="mf">0.003557</span>  <span class="mf">0.000978</span>  <span class="mf">0.000917</span>  <span class="mf">0.000859</span>  <span class="mf">0.000803</span>
<span class="mi">3</span>      <span class="mi">3</span>  <span class="mf">0.000890</span>  <span class="mf">0.000280</span>  <span class="mf">0.000237</span>  <span class="mf">0.000201</span>  <span class="mf">0.000172</span>
<span class="mi">4</span>      <span class="mi">4</span>  <span class="mf">0.000097</span>  <span class="mf">0.000023</span>  <span class="mf">0.000020</span>  <span class="mf">0.000023</span>  <span class="mf">0.000031</span>
<span class="mi">5</span>      <span class="mi">5</span>  <span class="mf">0.000320</span>  <span class="mf">0.000072</span>  <span class="mf">0.000079</span>  <span class="mf">0.000084</span>  <span class="mf">0.000086</span>
<span class="mi">6</span>      <span class="mi">6</span>  <span class="mf">0.004178</span>  <span class="mf">0.001147</span>  <span class="mf">0.001087</span>  <span class="mf">0.001014</span>  <span class="mf">0.000930</span>
<span class="mi">7</span>      <span class="mi">7</span>  <span class="mf">0.002613</span>  <span class="mf">0.000864</span>  <span class="mf">0.000713</span>  <span class="mf">0.000577</span>  <span class="mf">0.000459</span>
<span class="mi">8</span>      <span class="mi">8</span>  <span class="mf">0.002197</span>  <span class="mf">0.000817</span>  <span class="mf">0.000607</span>  <span class="mf">0.000446</span>  <span class="mf">0.000327</span>
<span class="mi">9</span>      <span class="mi">9</span>  <span class="mf">0.002605</span>  <span class="mf">0.000897</span>  <span class="mf">0.000695</span>  <span class="mf">0.000554</span>  <span class="mf">0.000458</span>
<span class="mi">10</span>    <span class="mi">10</span>  <span class="mf">0.000085</span>  <span class="mf">0.000036</span>  <span class="mf">0.000022</span>  <span class="mf">0.000015</span>  <span class="mf">0.000012</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Run the simulation with coin `C`, oracle `R` for ticks steps and with searched elements `searched`.</span>

<span class="sd">    This method does the same thing than `run`, but returns the probability of success at every steps. For every marked element m, the probability of measuring m at every step is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.</span>
<span class="sd">        R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.</span>
<span class="sd">        searched (list, optional): The list of marked elements. &quot;elements&quot; here means nodes if search_nodes was true when building the object, and means edges otherwise.</span>
<span class="sd">        ticks (int, optional): The number of time steps.</span>
<span class="sd">        progress (bool, optional): If True, a tqdm progress bar will be displayed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (pandas.DataFrame): A dataframe containing probabilities fo measuring marked positions. The column &quot;step&quot; denote the step number (or epoch) of the dynamic. For each marked element `m`, the column `m` denotes the probability of measuring `m` at any given step. The column `p_succ` denotes the probability of measuring any marked elements and is essentially the sum of all the other colmuns excepted &quot;step&quot;.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))</span>
<span class="sd">        &gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.edges()[0:4],ticks=10))</span>
<span class="sd">            step    p_succ    (0, 1)    (0, 2)    (0, 3)    (0, 4)</span>
<span class="sd">        0      0  0.000808  0.000202  0.000202  0.000202  0.000202</span>
<span class="sd">        1      1  0.003880  0.000994  0.000978  0.000962  0.000946</span>
<span class="sd">        2      2  0.009113  0.002467  0.002337  0.002214  0.002095</span>
<span class="sd">        3      3  0.013043  0.003875  0.003441  0.003044  0.002683</span>
<span class="sd">        4      4  0.013292  0.004433  0.003617  0.002918  0.002324</span>
<span class="sd">        5      5  0.010471  0.003820  0.002892  0.002162  0.001596</span>
<span class="sd">        6      6  0.007487  0.002620  0.002011  0.001579  0.001277</span>
<span class="sd">        7      7  0.005653  0.001645  0.001455  0.001324  0.001228</span>
<span class="sd">        8      8  0.004657  0.001321  0.001212  0.001107  0.001017</span>
<span class="sd">        9      9  0.004065  0.001494  0.001105  0.000824  0.000641</span>
<span class="sd">        10    10  0.004440  0.001913  0.001226  0.000784  0.000517</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100),search_nodes=True)</span>
<span class="sd">        &gt;&gt;&gt; print(qw.search(coins.H,coins.I,searched=qw.nodes()[0:4],ticks=10))</span>
<span class="sd">            step    p_succ         0         1         2         3</span>
<span class="sd">        0      0  0.000792  0.000198  0.000198  0.000198  0.000198</span>
<span class="sd">        1      1  0.000746  0.000198  0.000190  0.000182  0.000175</span>
<span class="sd">        2      2  0.003557  0.000978  0.000917  0.000859  0.000803</span>
<span class="sd">        3      3  0.000890  0.000280  0.000237  0.000201  0.000172</span>
<span class="sd">        4      4  0.000097  0.000023  0.000020  0.000023  0.000031</span>
<span class="sd">        5      5  0.000320  0.000072  0.000079  0.000084  0.000086</span>
<span class="sd">        6      6  0.004178  0.001147  0.001087  0.001014  0.000930</span>
<span class="sd">        7      7  0.002613  0.000864  0.000713  0.000577  0.000459</span>
<span class="sd">        8      8  0.002197  0.000817  0.000607  0.000446  0.000327</span>
<span class="sd">        9      9  0.002605  0.000897  0.000695  0.000554  0.000458</span>
<span class="sd">        10    10  0.000085  0.000036  0.000022  0.000015  0.000012</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">p</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
    <span class="n">p</span><span class="p">[</span><span class="s2">&quot;p_succ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_proba</span><span class="p">(</span><span class="n">searched</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="n">i</span><span class="p">])]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ticks</span><span class="p">)))</span> <span class="k">if</span> <span class="n">progress</span> <span class="k">else</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ticks</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">searched</span><span class="o">=</span><span class="n">searched</span><span class="p">)</span>

        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;p_succ&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_proba</span><span class="p">(</span><span class="n">searched</span><span class="p">))</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.get_T_P" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_T_P</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">waiting</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Computes the hitting time and probability of success for a given QW. </p>
<p>The waiting parameter is used to accumalate informations about the signal (recommended to be at least 10).</p>
<p>In details, this algorithm look at the time serie of the probability of success <span class="arithmatex">\(p(t)\)</span>. 
At any time step <span class="arithmatex">\(t\)</span>, we define <span class="arithmatex">\(T_{max}(t) = \underset{{t' \leq t}}{\mathrm{argmax }}\; p(t')\)</span> and <span class="arithmatex">\(T_{min}(t) = \underset{{t' \leq t}}{\mathrm{argmin }} \; p(t')\)</span>.</p>
<p>The algorithms computes the series <span class="arithmatex">\(p(t)\)</span>, <span class="arithmatex">\(T_{max}(t)\)</span>, <span class="arithmatex">\(T_{min}(t)\)</span> and stop when it encounters <code>t&gt;waiting</code> such that <span class="arithmatex">\(p(t)&lt;\frac{p\left(T_{max}(t)\right)+p\left(T_{max}(t)\right)}{2}\)</span>. 
It then returns <span class="arithmatex">\(T_{max}(t), p\left(T_{max}(t)\right)\)</span>.</p>
<p><strong>Warning:</strong> This function will reset the state of the QW.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>C</code></td>
        <td><code>numpy.array of complex</code></td>
        <td><p>The coin defined as a 2x2 numpy array of complex.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>R</code></td>
        <td><code>numpy.array of complex</code></td>
        <td><p>The oracle defined as a 2x2 numpy array of complex.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>searched</code></td>
        <td><code>list</code></td>
        <td><p>The list of marked elements. "elements" here means nodes if search_nodes was true when building the object, and means edges otherwise.</p></td>
        <td><code>[]</code></td>
      </tr>
      <tr>
        <td><code>waiting</code></td>
        <td><code>int</code></td>
        <td><p>The waiting time for the algorithm. Must be smaller than the hitting time.</p></td>
        <td><code>10</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(int*float)</code></td>
      <td><p>T:int,P:float respectively the hitting time and probability of success.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">get_T_P</span><span class="p">(</span><span class="n">coins</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="o">-</span><span class="n">coins</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="n">searched</span><span class="o">=</span><span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mf">0.9565191408575295</span><span class="p">)</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_T_P</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">waiting</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Computes the hitting time and probability of success for a given QW. </span>

<span class="sd">    The waiting parameter is used to accumalate informations about the signal (recommended to be at least 10).</span>

<span class="sd">    In details, this algorithm look at the time serie of the probability of success $p(t)$. </span>
<span class="sd">    At any time step $t$, we define $T_{max}(t) = \\underset{{t&#39; \\leq t}}{\\mathrm{argmax }}\\; p(t&#39;)$ and $T_{min}(t) = \\underset{{t&#39; \\leq t}}{\\mathrm{argmin }} \\; p(t&#39;)$.</span>

<span class="sd">    The algorithms computes the series $p(t)$, $T_{max}(t)$, $T_{min}(t)$ and stop when it encounters `t&gt;waiting` such that $p(t)&lt;\\frac{p\\left(T_{max}(t)\\right)+p\\left(T_{max}(t)\\right)}{2}$. </span>
<span class="sd">    It then returns $T_{max}(t), p\\left(T_{max}(t)\\right)$.</span>

<span class="sd">    **Warning:** This function will reset the state of the QW.</span>

<span class="sd">    Args:</span>
<span class="sd">        C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.</span>
<span class="sd">        R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.</span>
<span class="sd">        searched (list, optional): The list of marked elements. &quot;elements&quot; here means nodes if search_nodes was true when building the object, and means edges otherwise.</span>
<span class="sd">        waiting (int, optional): The waiting time for the algorithm. Must be smaller than the hitting time.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (int*float): T:int,P:float respectively the hitting time and probability of success.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(100))</span>
<span class="sd">        &gt;&gt;&gt; qw.get_T_P(coins.X,-coins.X,searched=qw.edges()[0:4])</span>
<span class="sd">        (28, 0.9565191408575295)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">carac</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">R</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_edge_index</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">],</span><span class="n">waiting</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ret</span>
</code></pre></div>
        </details>
    </div>

  </div>

<h2 id="others">Others</h2>


  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.reset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Reset the state to a diagonal one and reset the current step to 0.
Do not return anything.</p>

<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">set_state</span><span class="p">({</span><span class="n">edge</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.4472136</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>       <span class="p">,</span> <span class="mf">0.</span>       <span class="o">+</span><span class="mf">0.2236068</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.4472136</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>       <span class="p">,</span> <span class="mf">0.</span>       <span class="o">+</span><span class="mf">0.2236068</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.4472136</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>       <span class="p">,</span> <span class="mf">0.</span>       <span class="o">+</span><span class="mf">0.2236068</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.4472136</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>       <span class="p">,</span> <span class="mf">0.</span>       <span class="o">+</span><span class="mf">0.2236068</span><span class="n">j</span><span class="p">])}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]),</span>
 <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.35355339</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])}</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Reset the state to a diagonal one and reset the current step to 0.</span>
<span class="sd">    Do not return anything.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(4))</span>
<span class="sd">        &gt;&gt;&gt; qw.state()</span>
<span class="sd">        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>
<span class="sd">        &gt;&gt;&gt; qw.set_state({edge:[2,1j] for edge in qw.edges()})</span>
<span class="sd">        &gt;&gt;&gt; qw.state()</span>
<span class="sd">        {(0, 1): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">         (0, 3): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">         (1, 2): array([0.4472136+0.j       , 0.       +0.2236068j]),</span>
<span class="sd">         (2, 3): array([0.4472136+0.j       , 0.       +0.2236068j])}</span>
<span class="sd">        &gt;&gt;&gt; qw.reset()</span>
<span class="sd">        &gt;&gt;&gt; qw.state()</span>
<span class="sd">        {(0, 1): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (0, 3): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (1, 2): array([0.35355339+0.j, 0.35355339+0.j]),</span>
<span class="sd">         (2, 3): array([0.35355339+0.j, 0.35355339+0.j])}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.get_proba" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">searched</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>Returns the probability to measure on of the searched element.</p>
<p>!!! args " "
    searched (list of edge): The list of marked edges. Every element of the list must be an edge label (all of them are listed in <code>qw.edges</code>).</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(float)</code></td>
      <td><p>The probability of measuring any of the marked edges.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="mi">0</span><span class="p">]])</span>
<span class="mf">0.1666666666666667</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span><span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="mi">1</span><span class="p">]])</span>
<span class="mf">0.3333333333333334</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">get_proba</span><span class="p">(</span><span class="n">qw</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="mf">1.</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">searched</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Returns the probability to measure on of the searched element.</span>

<span class="sd">    Args:   </span>
<span class="sd">        searched (list of edge): The list of marked edges. Every element of the list must be an edge label (all of them are listed in `qw.edges`).</span>

<span class="sd">    Returns:</span>
<span class="sd">        (float): The probability of measuring any of the marked edges.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.complete_graph(4))</span>
<span class="sd">        &gt;&gt;&gt; qw.get_proba([qw.edges()[0]])</span>
<span class="sd">        0.1666666666666667</span>
<span class="sd">        &gt;&gt;&gt; qw.get_proba([qw.edges()[0],qw.edges()[1]])</span>
<span class="sd">        0.3333333333333334</span>
<span class="sd">        &gt;&gt;&gt; qw.get_proba(qw.edges())</span>
<span class="sd">        1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">get_proba</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_edge_index</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">])</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="qwgraph.qwsearch.QWSearch.get_unitary" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_unitary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">dataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents first">

      <p>For a given coin, oracle and set of searched edges, compute and return the unitary U coresponding to one step of the QW.</p>
<p>This method <strong>do not</strong> change the state of the QW.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>C</code></td>
        <td><code>numpy.array of complex</code></td>
        <td><p>The coin defined as a 2x2 numpy array of complex.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>R</code></td>
        <td><code>numpy.array of complex</code></td>
        <td><p>The oracle defined as a 2x2 numpy array of complex.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>searched</code></td>
        <td><code>list</code></td>
        <td><p>The list of marked elements. "elements" here means nodes if search_nodes was true when building the object, and means edges otherwise.</p></td>
        <td><code>[]</code></td>
      </tr>
      <tr>
        <td><code>dataframe</code></td>
        <td><code>bool</code></td>
        <td><p>If True, the result will be a pandas dataframe instead of a numpy array. </p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>progress</code></td>
        <td><code>bool</code></td>
        <td><p>If True, a tqdm progress bar will be displayed.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(numpy array or pandas dataframe)</code></td>
      <td><p>The unitary operator coresponding to one step of the dynamic. If dataframe is set to True, a pandas dataframe will be returned instead.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">QWSearch</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qw</span><span class="o">.</span><span class="n">get_unitary</span><span class="p">(</span><span class="n">coins</span><span class="o">.</span><span class="n">H</span><span class="p">,</span><span class="n">coins</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>
         <span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>
         <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>
         <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>
         <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>
         <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>qwgraph/qwsearch.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_unitary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="p">[],</span> <span class="n">dataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; For a given coin, oracle and set of searched edges, compute and return the unitary U coresponding to one step of the QW.</span>

<span class="sd">    This method **do not** change the state of the QW.</span>

<span class="sd">    Args:</span>
<span class="sd">        C (numpy.array of complex): The coin defined as a 2x2 numpy array of complex.</span>
<span class="sd">        R (numpy.array of complex): The oracle defined as a 2x2 numpy array of complex.</span>
<span class="sd">        searched (list, optional): The list of marked elements. &quot;elements&quot; here means nodes if search_nodes was true when building the object, and means edges otherwise.</span>
<span class="sd">        dataframe (bool, optional): If True, the result will be a pandas dataframe instead of a numpy array. </span>
<span class="sd">        progress (bool, optional): If True, a tqdm progress bar will be displayed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (numpy array or pandas dataframe): The unitary operator coresponding to one step of the dynamic. If dataframe is set to True, a pandas dataframe will be returned instead.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; qw = QWSearch(nx.cycle_graph(3))</span>
<span class="sd">        &gt;&gt;&gt; qw.get_unitary(coins.H,coins.I)</span>
<span class="sd">        array([[ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,</span>
<span class="sd">                 0.70710678+0.j,  0.        +0.j,  0.        +0.j],</span>
<span class="sd">               [ 0.        +0.j,  0.        +0.j,  0.        +0.j,</span>
<span class="sd">                 0.        +0.j,  0.70710678+0.j,  0.70710678+0.j],</span>
<span class="sd">               [ 0.70710678+0.j,  0.70710678+0.j,  0.        +0.j,</span>
<span class="sd">                 0.        +0.j,  0.        +0.j,  0.        +0.j],</span>
<span class="sd">               [ 0.        +0.j,  0.        +0.j,  0.        +0.j,</span>
<span class="sd">                 0.        +0.j,  0.70710678+0.j, -0.70710678+0.j],</span>
<span class="sd">               [ 0.70710678+0.j, -0.70710678+0.j,  0.        +0.j,</span>
<span class="sd">                 0.        +0.j,  0.        +0.j,  0.        +0.j],</span>
<span class="sd">               [ 0.        +0.j,  0.        +0.j,  0.70710678+0.j,</span>
<span class="sd">                -0.70710678+0.j,  0.        +0.j,  0.        +0.j]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">old_state</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
    <span class="n">old_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span>
    <span class="n">U</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">),</span><span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">))</span> <span class="k">if</span> <span class="n">progress</span> <span class="k">else</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__E</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">searched</span><span class="o">=</span><span class="n">searched</span><span class="p">)</span>
        <span class="n">U</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__qwf</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">old_state</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">old_step</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dataframe</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__amplitude_labels</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__amplitude_labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">U</span>
</code></pre></div>
        </details>
    </div>

  </div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.e1c3ead8.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>